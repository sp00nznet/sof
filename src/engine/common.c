/*
 * common.c - Engine common functions
 *
 * Based on Quake II common.c (id Software GPL).
 * Provides console output, error handling, and the main engine loop.
 *
 * SoF exports: Com_Printf, Com_DPrintf, Com_Error
 * Original addresses: Com_Printf=0x1DE70, Com_DPrintf=0x1E070, Com_Error=0x1E130
 *
 * Qcommon_Init (0x20BB0): Refs z_stats, error, disconnect, subliminal
 * Com_Init (0x23760): Refs cpu_mmx, cpu_amd3d, timescale, game
 */

#include "../common/qcommon.h"
#include "win32_compat.h"
#include "../renderer/r_local.h"
#include "../ghoul/ghoul.h"
#include "../sound/snd_local.h"
#include "../client/keys.h"
#include "../client/console.h"

#include <time.h>
#define _USE_MATH_DEFINES
#include <math.h>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

/* Forward declarations — input system (client/in_sdl.c) */
extern void IN_Init(void);
extern void IN_Shutdown(void);
extern void IN_GetMouseDelta(int *dx, int *dy);

/* Forward declarations — client input (client/cl_input.c) */
extern void CL_InitInput(void);
extern void CL_CreateCmd(usercmd_t *cmd, int msec);

/* Forward declarations — server frame (server/sv_game.c) */
extern void SV_RunGameFrame(void);
extern void SV_ClientThink(usercmd_t *cmd);
extern qboolean SV_GetPlayerState(vec3_t origin, vec3_t angles, float *viewheight);
extern qboolean SV_GetPlayerHealth(int *health, int *max_health);
extern const char *SV_GetPlayerWeapon(void);
extern qboolean SV_GetPlayerAmmo(int *ammo, int *ammo_max);
extern qboolean SV_GetPlayerMagazine(int *magazine, int *mag_max, int *reserve);
extern void SV_GetPlayerBlend(float *blend);
extern qboolean SV_GetPlayerArmor(int *armor, int *armor_max);
extern void SV_GetPlayerScore(int *kills, int *deaths, int *score);
extern void SV_GetPlayerAccuracy(int *shots_fired, int *shots_hit, int *headshots);
extern qboolean SV_GetCrosshairTarget(int *health, int *max_health, const char **name);
extern void SV_GetLevelStats(int *killed_monsters, int *total_monsters,
                             int *found_secrets, int *total_secrets);
extern int  SV_GetEntityCount(void);
extern qboolean SV_GetPlayerZoom(float *fov);
extern int  SV_GetPlayerWeaponIndex(void);
extern qboolean SV_GetPlayerVelocity(vec3_t vel);
extern float SV_GetPlayerFireTime(void);
extern qboolean SV_IsPlayerReloading(void);
extern qboolean SV_IsPlayerDead(void);
extern const char *SV_GetNearbyItemName(void);
extern int  SV_GetPlayerKeys(void);

/* Forward declarations — view weapon (renderer/r_main.c) */
extern void R_SetViewWeaponState(int weapon_id, float kick, float bob_phase,
                                 float bob_amount, float sway_yaw, float sway_pitch,
                                 qboolean reloading);

/* Forward declaration — freecam toggle (defined below in client section) */
static void Cmd_Freecam_f(void);

/* Forward declaration — client command forwarding */
extern void SV_ExecuteClientCommand(void);

static void Cmd_SaveGame_f(void)
{
    const char *name = Cmd_Argc() > 1 ? Cmd_Argv(1) : "quick";
    char buf[256];
    snprintf(buf, sizeof(buf), "save %s", name);
    Cmd_TokenizeString(buf, qfalse);
    SV_ExecuteClientCommand();
}

static void Cmd_LoadGame_f(void)
{
    const char *name = Cmd_Argc() > 1 ? Cmd_Argv(1) : "quick";
    char buf[256];
    snprintf(buf, sizeof(buf), "load %s", name);
    Cmd_TokenizeString(buf, qfalse);
    SV_ExecuteClientCommand();
}

static void Cmd_ForwardToServer(void)
{
    /* Re-tokenize with "cmd" stripped so gi.argv(0) returns the actual command */
    const char *args = Cmd_Args();
    if (args && args[0]) {
        Cmd_TokenizeString((char *)args, qfalse);
        SV_ExecuteClientCommand();
    }
}

extern void Key_WriteBindings(FILE *f);

static void Cmd_WriteConfig_f(void)
{
    const char *filename = Cmd_Argc() > 1 ? Cmd_Argv(1) : "config.cfg";
    FILE *f;

    f = fopen(filename, "w");
    if (!f) {
        Com_Printf("Couldn't write %s\n", filename);
        return;
    }

    fprintf(f, "// Generated by SoF Recomp\n\n");
    fprintf(f, "// Key bindings\n");
    Key_WriteBindings(f);
    fprintf(f, "\n// Cvars\n");
    fclose(f);

    /* Cvar_WriteVariables appends to file */
    Cvar_WriteVariables(filename);

    Com_Printf("Wrote %s\n", filename);
}

/* Forward declarations — HUD, menu, scoreboard, chat, damage, pickup, killfeed */
static void SCR_DrawHUD(float frametime);
static void SCR_DrawMenu(void);
static void SCR_DrawScoreboard(void);
static void SCR_DrawChat(void);
static void SCR_DrawDamageNumbers(void);
static void SCR_DrawPickupMessages(void);
static void SCR_DrawKillFeed(void);
static void SCR_DrawMinimap(void);
static void SCR_DrawDeathScreen(void);
static void SCR_DrawHitMarker(void);
static void SCR_DrawDamageDirection(void);
static void SCR_DrawBloodSplatters(void);
static void SCR_UpdateFade(float frametime);
static void SCR_DrawFade(void);
void SCR_StartFade(float target, float speed, float hold);
void SCR_FadeIn(float speed);
static void SCR_DrawObjectives(void);
static void SCR_DrawIntermission(void);

/* Intermission state */
static qboolean     cl_intermission;
static float        cl_intermission_time;
static char         cl_nextmap[64];

/* Screen fade state */
static float    scr_fade_alpha;         /* current fade alpha (0=clear, 1=black) */
static float    scr_fade_target;        /* target alpha */
static float    scr_fade_speed;         /* alpha change per second */
static float    scr_fade_hold;          /* seconds to hold at target */
static float    scr_fade_hold_time;     /* when hold started */

/* ANGLE2SHORT / SHORT2ANGLE for usercmd angle encoding */
#define ANGLE2SHORT(x)  ((int)((x)*65536.0f/360.0f) & 65535)
#define SHORT2ANGLE(x)  ((x)*(360.0f/65536.0f))

/* ==========================================================================
   Global Cvars
   ========================================================================== */

cvar_t  *developer;
cvar_t  *timescale;
cvar_t  *fixedtime;
cvar_t  *dedicated;
cvar_t  *com_speeds;
cvar_t  *logfile_cvar;
cvar_t  *showtrace;

/* SoF-specific cvars discovered through binary analysis */
cvar_t  *sof_version;
cvar_t  *gore_detail;

static FILE *logfile;
static int  server_state;

/* ==========================================================================
   Console Output
   ========================================================================== */

static char     com_printbuf[8192];

void Com_Printf(const char *fmt, ...)
{
    va_list argptr;
    char    msg[4096];

    va_start(argptr, fmt);
    vsnprintf(msg, sizeof(msg), fmt, argptr);
    va_end(argptr);

    /* Print to stdout */
    fputs(msg, stdout);
    fflush(stdout);

    /* Log to file if enabled */
    if (logfile) {
        fputs(msg, logfile);
        fflush(logfile);
    }

    /* Route to in-game console */
    Con_Print(msg);
}

void Com_DPrintf(const char *fmt, ...)
{
    va_list argptr;
    char    msg[4096];

    if (!developer || !developer->value)
        return;

    va_start(argptr, fmt);
    vsnprintf(msg, sizeof(msg), fmt, argptr);
    va_end(argptr);

    Com_Printf("%s", msg);
}

/* ==========================================================================
   Error Handling
   ========================================================================== */

void Com_Error(int code, const char *fmt, ...)
{
    va_list     argptr;
    static char msg[4096];
    static int  recursive = 0;

    if (recursive)
        Sys_Error("recursive error after: %s", msg);

    recursive = 1;

    va_start(argptr, fmt);
    vsnprintf(msg, sizeof(msg), fmt, argptr);
    va_end(argptr);

    switch (code) {
    case ERR_DISCONNECT:
        CL_Drop();
        recursive = 0;
        return;

    case ERR_DROP:
        Com_Printf("********************\nERROR: %s\n********************\n", msg);
        SV_Shutdown(va("server crashed: %s\n", msg), qfalse);
        CL_Drop();
        recursive = 0;
        return;

    case ERR_FATAL:
    default:
        SV_Shutdown(va("server fatal crashed: %s\n", msg), qfalse);
        CL_Shutdown();
        break;
    }

    Sys_Error("%s", msg);
}

/* ==========================================================================
   Engine Initialization
   ========================================================================== */

void Qcommon_Init(int argc, char **argv)
{
    Com_Printf("\n");
    Com_Printf("=== Soldier of Fortune ===\n");
    Com_Printf("Static Recompilation v%s\n", "0.1.0");
    Com_Printf("Based on id Tech 2 (Quake II Engine)\n");
    Com_Printf("Original by Raven Software, 2000\n");
    Com_Printf("\n");

    /* Initialize subsystems in dependency order */
    Z_Init();
    Cbuf_Init();
    Cmd_Init();
    Cvar_Init();

    /* Register core commands */
    Cmd_AddCommand("quit", Sys_Quit);
    Cmd_AddCommand("error", NULL);  /* placeholder */
    Cmd_AddCommand("freecam", Cmd_Freecam_f);
    Cmd_AddCommand("cmd", Cmd_ForwardToServer);
    Cmd_AddCommand("savegame", Cmd_SaveGame_f);
    Cmd_AddCommand("loadgame", Cmd_LoadGame_f);
    Cmd_AddCommand("writeconfig", Cmd_WriteConfig_f);
    Cmd_AddCommand("vid_restart", R_SetMode);
    Cmd_AddCommand("screenshot", R_Screenshot_f);

    /* Register core cvars */
    developer = Cvar_Get("developer", "0", 0);
    timescale = Cvar_Get("timescale", "1", 0);
    fixedtime = Cvar_Get("fixedtime", "0", 0);
    dedicated = Cvar_Get("dedicated", "0", CVAR_NOSET);
    com_speeds = Cvar_Get("com_speeds", "0", 0);
    logfile_cvar = Cvar_Get("logfile", "0", 0);
    showtrace = Cvar_Get("showtrace", "0", 0);

    /* SoF-specific cvars */
    sof_version = Cvar_Get("version", "SoF Recomp v0.1.0", CVAR_SERVERINFO | CVAR_NOSET);
    gore_detail = Cvar_Get("gore_detail", "2", CVAR_ARCHIVE);  /* 0=off, 1=low, 2=full */

    /* SoF gore zone cvars (from binary analysis: 85 cvars registered) */
    Cvar_Get("ghl_specular", "1", CVAR_ARCHIVE);
    Cvar_Get("ghl_mip", "1", CVAR_ARCHIVE);

    /* Initialize filesystem */
    FS_InitFilesystem();

    /* Execute default config */
    Cbuf_AddText("exec default.cfg\n");
    Cbuf_AddText("exec config.cfg\n");
    Cbuf_Execute();

    /* Parse command line arguments */
    {
        int i;
        for (i = 1; i < argc; i++) {
            if (argv[i][0] == '+') {
                Cbuf_AddText(va("%s ", argv[i] + 1));
                /* Add remaining args until next + command */
                while (i + 1 < argc && argv[i + 1][0] != '+') {
                    i++;
                    Cbuf_AddText(va("%s ", argv[i]));
                }
                Cbuf_AddText("\n");
            }
        }
        Cbuf_Execute();
    }

    /* Initialize subsystems that depend on filesystem */
    /* TODO: NET_Init(), Netchan_Init() */

    Com_Printf("====== Soldier of Fortune Initialized ======\n\n");

    /* Initialize GHOUL model system */
    GHOUL_Init();

    /* Initialize game module (was gamex86.dll in original) */
    SV_InitGameProgs();

    /* Initialize console */
    Con_Init();

    /* Initialize input */
    IN_Init();
    CL_InitInput();

    /* Initialize renderer */
    if (!dedicated->value) {
        R_Init(NULL, NULL);
    }

    /* Initialize sound (replaces Defsnd.dll/EAXSnd.dll/A3Dsnd.dll) */
    S_Init();
}

/* ==========================================================================
   Main Frame
   ========================================================================== */

void Qcommon_Frame(int msec)
{
    int     time_before, time_between, time_after;

    if (fixedtime && fixedtime->value)
        msec = (int)fixedtime->value;
    else if (timescale && timescale->value)
        msec = (int)(msec * timescale->value);

    if (msec < 1)
        msec = 1;

    if (com_speeds && com_speeds->value)
        time_before = Sys_Milliseconds();

    /* Execute any pending console commands */
    Cbuf_Execute();

    if (com_speeds && com_speeds->value)
        time_between = Sys_Milliseconds();

    /* Run server frame */
    SV_Frame(msec);

    /* Run client frame (input, view setup) */
    if (!dedicated || !dedicated->value) {
        CL_Frame(msec);

        /* Animate console slide */
        {
            float speed = msec * 0.004f;  /* ~4 units per ms */
            if (con.current_frac < con.dest_frac) {
                con.current_frac += speed;
                if (con.current_frac > con.dest_frac)
                    con.current_frac = con.dest_frac;
            } else if (con.current_frac > con.dest_frac) {
                con.current_frac -= speed;
                if (con.current_frac < con.dest_frac)
                    con.current_frac = con.dest_frac;
            }
        }

        /* Update sound listener position */
        {
            vec3_t snd_origin, snd_forward, snd_right, snd_up;
            float angles[3];
            float sp, sy, cp, cy, sr, cr;

            R_GetCameraOrigin(snd_origin);
            R_GetCameraAngles(angles);

            /* AngleVectors: pitch=angles[0], yaw=angles[1], roll=angles[2] */
            sp = (float)sin(angles[0] * M_PI / 180.0);
            cp = (float)cos(angles[0] * M_PI / 180.0);
            sy = (float)sin(angles[1] * M_PI / 180.0);
            cy = (float)cos(angles[1] * M_PI / 180.0);
            sr = (float)sin(angles[2] * M_PI / 180.0);
            cr = (float)cos(angles[2] * M_PI / 180.0);

            snd_forward[0] = cp * cy;
            snd_forward[1] = cp * sy;
            snd_forward[2] = -sp;
            snd_right[0] = (-1 * sr * sp * cy + -1 * cr * -sy);
            snd_right[1] = (-1 * sr * sp * sy + -1 * cr * cy);
            snd_right[2] = -1 * sr * cp;
            snd_up[0] = (cr * sp * cy + -sr * -sy);
            snd_up[1] = (cr * sp * sy + -sr * cy);
            snd_up[2] = cr * cp;

            S_Update(snd_origin, snd_forward, snd_right, snd_up);
        }

        /* Update screen fade */
        SCR_UpdateFade(msec / 1000.0f);

        /* Render frame */
        R_BeginFrame(0.0f);
        if (cl_intermission) {
            SCR_DrawIntermission();
        } else {
            SCR_DrawHUD(msec / 1000.0f);
            SCR_DrawBloodSplatters();
            SCR_DrawDamageNumbers();
            SCR_DrawHitMarker();
            SCR_DrawDamageDirection();
            SCR_DrawPickupMessages();
            SCR_DrawKillFeed();
            SCR_DrawDeathScreen();
            SCR_DrawObjectives();
            SCR_DrawChat();
            SCR_DrawScoreboard();
        }
        SCR_DrawMenu();
        Con_DrawNotify();
        Con_DrawConsole(con.current_frac);
        SCR_DrawFade();  /* fade overlay drawn last, on top of everything */
        R_EndFrame();
    }

    if (com_speeds && com_speeds->value) {
        time_after = Sys_Milliseconds();
        Com_Printf("all:%3d sv:%3d cl:%3d\n",
            time_after - time_before,
            time_between - time_before,
            time_after - time_between);
    }
}

/* ==========================================================================
   Shutdown
   ========================================================================== */

void Qcommon_Shutdown(void)
{
    /* Auto-save config on clean shutdown */
    Cmd_WriteConfig_f();

    if (logfile) {
        fclose(logfile);
        logfile = NULL;
    }
}

/* ==========================================================================
   Client State
   ========================================================================== */

typedef enum {
    CA_DISCONNECTED,    /* not connected to a server */
    CA_CONNECTING,      /* awaiting connection response */
    CA_CONNECTED,       /* connection established, loading map */
    CA_ACTIVE           /* fully in-game, rendering world */
} connstate_t;

static connstate_t  cl_state = CA_DISCONNECTED;
static refdef_t     cl_refdef;          /* current frame's render view */
static float        cl_time;            /* accumulated time */
static vec3_t       cl_viewangles;      /* accumulated mouse look angles */
static qboolean     cl_use_freecam;     /* toggle: freecam vs player movement */

/* ==========================================================================
   View Effects State — Head bob, weapon kick, sway, screen shake
   ========================================================================== */

/* Head bob */
static float cl_bob_cycle;              /* bob phase accumulator */
static float cl_bob_amount;             /* current bob amplitude */

/* Weapon sway (view angle lag) */
static float cl_sway_yaw;              /* current sway offset (yaw) */
static float cl_sway_pitch;            /* current sway offset (pitch) */
static float cl_prev_yaw;              /* previous frame yaw for delta */
static float cl_prev_pitch;            /* previous frame pitch for delta */

/* Weapon kick */
static float cl_kick_amount;           /* current recoil (0..1, decays) */
static float cl_last_fire_check;       /* last fire time we checked */

/* Screen shake */
static float cl_shake_intensity;       /* current shake strength */
static float cl_shake_duration;        /* remaining shake time */
static float cl_shake_time;            /* total shake duration for decay */

/* Footstep sounds */
static float cl_footstep_accum;        /* accumulated step distance */
#define FOOTSTEP_INTERVAL 3.5f         /* bob cycles between footsteps */

/* View smoothing — stair stepping, crouch transitions, landing recovery */
static float cl_smooth_viewheight;     /* smoothed viewheight (lerps to target) */
static float cl_smooth_z_offset;       /* smoothed stair step Z offset */
static float cl_prev_z;               /* previous frame Z for step detection */
static float cl_landing_dip;          /* landing recovery dip amount */
static float cl_prev_z_vel;          /* previous Z velocity for landing detect */
static qboolean cl_smooth_inited;     /* first-frame guard */

void SCR_AddScreenShake(float intensity, float duration)
{
    /* Stack shakes — take the stronger one if already shaking */
    if (intensity > cl_shake_intensity) {
        cl_shake_intensity = intensity;
        cl_shake_duration = duration;
        cl_shake_time = duration;
    } else if (cl_shake_duration > 0) {
        /* Extend existing shake */
        cl_shake_duration += duration * 0.5f;
    }
}

/* ==========================================================================
   Mission Objective Display
   ========================================================================== */

#define MAX_OBJECTIVES  4
#define OBJECTIVE_LEN   128

static char objectives[MAX_OBJECTIVES][OBJECTIVE_LEN];
static int  objective_count;
static float objective_flash_time;  /* timestamp of last objective update */

void SCR_SetObjective(int index, const char *text)
{
    if (index < 0 || index >= MAX_OBJECTIVES) return;
    if (text && text[0])
        Q_strncpyz(objectives[index], text, OBJECTIVE_LEN);
    else
        objectives[index][0] = '\0';
    if (index >= objective_count)
        objective_count = index + 1;
    objective_flash_time = (float)Sys_Milliseconds() / 1000.0f;
}

void SCR_ClearObjectives(void)
{
    int i;
    for (i = 0; i < MAX_OBJECTIVES; i++)
        objectives[i][0] = '\0';
    objective_count = 0;
}

static void SCR_DrawObjectives(void)
{
    int i;
    float now = (float)Sys_Milliseconds() / 1000.0f;
    float flash_age = now - objective_flash_time;
    int x = 10;
    int y = 60;

    if (objective_count == 0) return;

    /* Brief flash when new objective added */
    if (flash_age < 3.0f) {
        float a = flash_age < 2.0f ? 1.0f : (3.0f - flash_age);

        R_SetDrawColor(1.0f, 0.8f, 0.0f, a * 0.9f);
        R_DrawString(x, y, "OBJECTIVE:");
        y += 14;

        for (i = 0; i < objective_count; i++) {
            if (objectives[i][0] == '\0') continue;
            R_SetDrawColor(1.0f, 1.0f, 1.0f, a * 0.85f);
            R_DrawString(x + 8, y, objectives[i]);
            y += 12;
        }
        R_SetDrawColor(1.0f, 1.0f, 1.0f, 1.0f);
    }
}

/*
 * SCR_BeginIntermission — Called by changelevel to show stats before map change
 */
void SCR_BeginIntermission(const char *nextmap)
{
    cl_intermission = qtrue;
    cl_intermission_time = cl_time;
    Q_strncpyz(cl_nextmap, nextmap, sizeof(cl_nextmap));
    Com_Printf("Intermission: next map %s\n", nextmap);

    /* Fade to black for level transition */
    SCR_StartFade(0.8f, 1.5f, 0);
}

void CL_Init(void)
{
    memset(&cl_refdef, 0, sizeof(cl_refdef));
    cl_state = CA_DISCONNECTED;
    cl_time = 0;
    VectorClear(cl_viewangles);
    cl_use_freecam = qfalse;
    cl_smooth_inited = qfalse;
}

void CL_Drop(void)
{
    cl_state = CA_DISCONNECTED;
}

void CL_Shutdown(void)
{
    S_Shutdown();
    IN_Shutdown();
    R_Shutdown();
}

/* Toggle freecam console command */
static void Cmd_Freecam_f(void)
{
    cl_use_freecam = !cl_use_freecam;
    Com_Printf("Freecam: %s\n", cl_use_freecam ? "ON" : "OFF");
}

/*
 * CL_Frame — Client frame processing
 *
 * Runs every frame. Handles input, updates the view, builds refdef_t.
 * In the original Q2, this also handled network parsing and prediction.
 * For our unified binary, the server runs in-process.
 */
void CL_Frame(int msec)
{
    float frametime = msec / 1000.0f;
    cl_time += frametime;

    /* If world is loaded and we're disconnected, go active */
    if (R_WorldLoaded() && cl_state < CA_ACTIVE)
        cl_state = CA_ACTIVE;

    if (cl_state != CA_ACTIVE)
        return;

    /* Gather mouse input (always, for both modes) */
    if (!Con_IsVisible()) {
        int mx, my;
        IN_GetMouseDelta(&mx, &my);
        cl_viewangles[1] -= mx * 0.15f;    /* yaw */
        cl_viewangles[0] += my * 0.15f;    /* pitch */
        if (cl_viewangles[0] > 89) cl_viewangles[0] = 89;
        if (cl_viewangles[0] < -89) cl_viewangles[0] = -89;
    }

    if (cl_use_freecam) {
        /* Freecam mode — direct camera control */
        if (!Con_IsVisible()) {
            extern qboolean key_down[];
            float fwd = 0, side = 0, up = 0;
            if (key_down['w']) fwd += 1;
            if (key_down['s']) fwd -= 1;
            if (key_down['d']) side += 1;
            if (key_down['a']) side -= 1;
            if (key_down[' ']) up += 200.0f * frametime;
            if (key_down[133]) up -= 200.0f * frametime;

            R_SetCameraAngles(cl_viewangles);
            R_UpdateCamera(fwd, side, up, 0, 0, frametime);
        }

        /* Build refdef from freecam */
        {
            vec3_t org, ang;
            R_GetCameraOrigin(org);
            R_GetCameraAngles(ang);

            memset(&cl_refdef, 0, sizeof(cl_refdef));
            cl_refdef.x = 0;
            cl_refdef.y = 0;
            cl_refdef.width = g_display.width;
            cl_refdef.height = g_display.height;
            cl_refdef.fov_x = 90.0f;
            cl_refdef.fov_y = 73.74f;
            cl_refdef.time = cl_time;
            VectorCopy(org, cl_refdef.vieworg);
            VectorCopy(ang, cl_refdef.viewangles);
        }
    } else {
        /* Player movement mode — build usercmd, send to game */
        usercmd_t cmd;
        CL_CreateCmd(&cmd, msec);

        /* Pack view angles into usercmd */
        cmd.angles[0] = (short)ANGLE2SHORT(cl_viewangles[0]);
        cmd.angles[1] = (short)ANGLE2SHORT(cl_viewangles[1]);
        cmd.angles[2] = 0;

        /* Send to game module */
        if (!Con_IsVisible())
            SV_ClientThink(&cmd);

        /* Build refdef from player entity state */
        {
            vec3_t org, ang;
            float vh = 0;

            if (SV_GetPlayerState(org, ang, &vh)) {
                /* ---- View smoothing: stair step, crouch, landing ---- */
                {
                    if (!cl_smooth_inited) {
                        cl_smooth_viewheight = vh;
                        cl_prev_z = org[2];
                        cl_smooth_z_offset = 0;
                        cl_landing_dip = 0;
                        cl_smooth_inited = qtrue;
                    }

                    /* Detect stair steps: sudden Z change 2-18 units */
                    {
                        float z_delta = org[2] - cl_prev_z;
                        if (z_delta > 2.0f && z_delta < 20.0f) {
                            /* Stepped up — smooth the transition */
                            cl_smooth_z_offset -= z_delta;
                        } else if (z_delta < -2.0f && z_delta > -20.0f) {
                            /* Stepped down */
                            cl_smooth_z_offset -= z_delta;
                        }
                        cl_prev_z = org[2];
                    }

                    /* Decay stair step offset toward zero */
                    if (cl_smooth_z_offset > 0) {
                        cl_smooth_z_offset -= frametime * 80.0f;
                        if (cl_smooth_z_offset < 0) cl_smooth_z_offset = 0;
                    } else if (cl_smooth_z_offset < 0) {
                        cl_smooth_z_offset += frametime * 80.0f;
                        if (cl_smooth_z_offset > 0) cl_smooth_z_offset = 0;
                    }

                    /* Smooth crouch transitions — lerp viewheight */
                    cl_smooth_viewheight += (vh - cl_smooth_viewheight) * frametime * 12.0f;

                    /* Landing recovery dip */
                    if (cl_landing_dip > 0) {
                        cl_landing_dip -= frametime * 6.0f;
                        if (cl_landing_dip < 0) cl_landing_dip = 0;
                    }

                    /* Apply smoothed values */
                    org[2] += cl_smooth_viewheight + cl_smooth_z_offset - cl_landing_dip;
                }

                /* ---- Head bob + landing detection ---- */
                {
                    vec3_t vel;
                    float speed = 0;

                    if (SV_GetPlayerVelocity(vel)) {
                        speed = (float)sqrt(vel[0] * vel[0] + vel[1] * vel[1]);

                        /* Landing detection: was falling, now stopped */
                        if (cl_prev_z_vel < -150.0f && vel[2] > -50.0f) {
                            float impact = -cl_prev_z_vel;
                            cl_landing_dip = impact * 0.008f;
                            if (cl_landing_dip > 4.0f) cl_landing_dip = 4.0f;
                        }
                        cl_prev_z_vel = vel[2];
                    }

                    if (speed > 20.0f) {
                        /* Running — cycle the bob */
                        float bob_speed = speed * 0.006f;
                        if (bob_speed > 1.5f) bob_speed = 1.5f;
                        cl_bob_cycle += frametime * bob_speed * 12.0f;

                        /* Bob amplitude based on speed */
                        cl_bob_amount = speed * 0.0012f;
                        if (cl_bob_amount > 0.8f) cl_bob_amount = 0.8f;

                        /* Apply view bob to eye height */
                        org[2] += (float)sin(cl_bob_cycle) * cl_bob_amount * 1.5f;

                        /* Footstep sounds — play at bob cycle intervals */
                        cl_footstep_accum += frametime * bob_speed * 12.0f;
                        if (cl_footstep_accum >= FOOTSTEP_INTERVAL) {
                            static int step_idx;
                            static const char *step_sounds[] = {
                                "player/step1.wav",
                                "player/step2.wav",
                                "player/step3.wav",
                                "player/step4.wav"
                            };
                            S_StartLocalSound(step_sounds[step_idx & 3]);
                            step_idx++;
                            cl_footstep_accum -= FOOTSTEP_INTERVAL;
                        }
                    } else {
                        /* Standing still — decay bob */
                        cl_bob_amount *= 0.9f;
                        if (cl_bob_amount < 0.01f) cl_bob_amount = 0;
                    }
                }

                /* ---- Weapon sway (angle lag) ---- */
                {
                    float yaw_delta = ang[1] - cl_prev_yaw;
                    float pitch_delta = ang[0] - cl_prev_pitch;

                    /* Normalize yaw delta */
                    while (yaw_delta > 180) yaw_delta -= 360;
                    while (yaw_delta < -180) yaw_delta += 360;

                    /* Add delta to sway, then decay toward zero */
                    cl_sway_yaw += yaw_delta * 0.15f;
                    cl_sway_pitch += pitch_delta * 0.12f;
                    cl_sway_yaw *= (1.0f - frametime * 8.0f);
                    cl_sway_pitch *= (1.0f - frametime * 8.0f);

                    /* Clamp sway range */
                    if (cl_sway_yaw > 2.0f) cl_sway_yaw = 2.0f;
                    if (cl_sway_yaw < -2.0f) cl_sway_yaw = -2.0f;
                    if (cl_sway_pitch > 1.5f) cl_sway_pitch = 1.5f;
                    if (cl_sway_pitch < -1.5f) cl_sway_pitch = -1.5f;

                    cl_prev_yaw = ang[1];
                    cl_prev_pitch = ang[0];
                }

                /* ---- Weapon kick (recoil) ---- */
                {
                    float fire_time = SV_GetPlayerFireTime();
                    if (fire_time > cl_last_fire_check && fire_time > 0) {
                        /* New shot detected — apply kick */
                        cl_kick_amount = 1.0f;
                        cl_last_fire_check = fire_time;
                    }

                    /* Decay kick */
                    if (cl_kick_amount > 0) {
                        cl_kick_amount -= frametime * 6.0f;
                        if (cl_kick_amount < 0) cl_kick_amount = 0;
                    }
                }

                /* ---- Screen shake ---- */
                {
                    if (cl_shake_duration > 0) {
                        float decay = cl_shake_duration / cl_shake_time;
                        float shake_x = ((float)(rand() % 200) - 100.0f) * 0.01f *
                                        cl_shake_intensity * decay;
                        float shake_y = ((float)(rand() % 200) - 100.0f) * 0.01f *
                                        cl_shake_intensity * decay;

                        ang[0] += shake_x;
                        ang[1] += shake_y;
                        org[2] += ((float)(rand() % 100) - 50.0f) * 0.01f *
                                  cl_shake_intensity * decay;

                        cl_shake_duration -= frametime;
                        if (cl_shake_duration <= 0) {
                            cl_shake_duration = 0;
                            cl_shake_intensity = 0;
                        }
                    }
                }

                memset(&cl_refdef, 0, sizeof(cl_refdef));
                cl_refdef.x = 0;
                cl_refdef.y = 0;
                cl_refdef.width = g_display.width;
                cl_refdef.height = g_display.height;
                cl_refdef.fov_x = 90.0f;
                cl_refdef.fov_y = 73.74f;

                /* Apply zoom FOV if scoped */
                {
                    float zoom_fov;
                    if (SV_GetPlayerZoom(&zoom_fov) && zoom_fov > 0) {
                        cl_refdef.fov_x = zoom_fov;
                        cl_refdef.fov_y = zoom_fov * 0.75f;
                    }
                }

                cl_refdef.time = cl_time;
                VectorCopy(org, cl_refdef.vieworg);
                VectorCopy(ang, cl_refdef.viewangles);

                /* Sync camera for PVS culling */
                R_SetCameraOrigin(org);
                R_SetCameraAngles(ang);

                /* Get damage blend (screen flash effect) */
                SV_GetPlayerBlend(cl_refdef.blend);

                /* Check underwater for fog effect */
                {
                    extern qboolean SV_IsPlayerUnderwater(void);
                    if (SV_IsPlayerUnderwater()) {
                        cl_refdef.rdflags |= RDF_UNDERWATER;
                        /* Add blue tint if not already blending */
                        if (cl_refdef.blend[3] < 0.1f) {
                            cl_refdef.blend[0] = 0.0f;
                            cl_refdef.blend[1] = 0.1f;
                            cl_refdef.blend[2] = 0.4f;
                            cl_refdef.blend[3] = 0.15f;
                        }
                    }
                }

                /* ---- Update view weapon state for renderer ---- */
                R_SetViewWeaponState(
                    SV_GetPlayerWeaponIndex(),
                    cl_kick_amount,
                    cl_bob_cycle,
                    cl_bob_amount,
                    cl_sway_yaw,
                    cl_sway_pitch,
                    SV_IsPlayerReloading()
                );
            }
        }
    }
}

/* ==========================================================================
   HUD Drawing
   ========================================================================== */

/* Pickup message display */
static char     hud_pickup_msg[64];
static float    hud_pickup_time;

void HUD_SetPickupMessage(const char *msg)
{
    Q_strncpyz(hud_pickup_msg, msg, sizeof(hud_pickup_msg));
    hud_pickup_time = 3.0f;  /* display for 3 seconds */
}

/* Crosshair spread expansion — set by game when firing */
static float crosshair_spread_extra;  /* extra gap from weapon spread */
static float crosshair_spread_decay;  /* decay timer */

void SCR_SetCrosshairSpread(float spread)
{
    crosshair_spread_extra = spread * 200.0f;  /* scale to pixels */
    if (crosshair_spread_extra > 20) crosshair_spread_extra = 20;
}

/* ==========================================================================
   Main Menu System
   ========================================================================== */

#define MENU_ITEMS  5
static const char *menu_labels[MENU_ITEMS] = {
    "NEW GAME", "LOAD GAME", "OPTIONS", "CREDITS", "QUIT"
};

#define MAP_COUNT  8
static const char *map_names[MAP_COUNT] = {
    "sof1", "sof2", "sof3", "sof4", "sof5", "sof6", "sof7", "sof8"
};
static const char *map_titles[MAP_COUNT] = {
    "New York - Subway",
    "New York - Streets",
    "Iraq - Village",
    "Iraq - Compound",
    "Siberia - Train Yard",
    "Siberia - Base",
    "Tokyo - Rooftops",
    "Tokyo - Tower"
};

static int  menu_active = 0;    /* 0=hidden, 1=main, 2=options, 3=map select */
static int  menu_cursor = 0;
static int  map_cursor = 0;
static int  opt_cursor = 0;

#define OPT_ITEMS 6  /* sensitivity, volume, resolution, fullscreen, gore, difficulty */

/* Exposed to key handler */
int  M_IsActive(void) { return menu_active; }

void M_Open(void)
{
    menu_active = 1;
    menu_cursor = 0;
}

void M_Close(void)
{
    menu_active = 0;
}

void M_Keydown(int key)
{
    if (menu_active == 4) {
        /* Credits screen — ESC returns to main */
        if (key == K_ESCAPE || key == K_ENTER || key == K_SPACE) {
            menu_active = 1;
            menu_cursor = 3;
        }
        return;
    }

    if (menu_active == 2) {
        /* Options sub-menu — interactive settings */
        if (key == K_ESCAPE) {
            menu_active = 1;
            menu_cursor = 2;
        } else if (key == K_UPARROW || key == 'k') {
            opt_cursor--;
            if (opt_cursor < 0) opt_cursor = OPT_ITEMS - 1;
        } else if (key == K_DOWNARROW || key == 'j') {
            opt_cursor++;
            if (opt_cursor >= OPT_ITEMS) opt_cursor = 0;
        } else if (key == K_LEFTARROW || key == K_RIGHTARROW) {
            float dir = (key == K_RIGHTARROW) ? 1.0f : -1.0f;
            switch (opt_cursor) {
            case 0: { /* Sensitivity */
                float s = Cvar_VariableValue("sensitivity") + dir * 0.5f;
                if (s < 0.5f) s = 0.5f;
                if (s > 20.0f) s = 20.0f;
                Cvar_SetValue("sensitivity", s);
                break;
            }
            case 1: { /* Volume */
                float v = Cvar_VariableValue("s_volume") + dir * 0.1f;
                if (v < 0.0f) v = 0.0f;
                if (v > 1.0f) v = 1.0f;
                Cvar_SetValue("s_volume", v);
                break;
            }
            case 2: { /* Resolution */
                int mode = (int)Cvar_VariableValue("r_mode") + (int)dir;
                if (mode < 0) mode = 14;
                if (mode > 14) mode = 0;
                Cvar_SetValue("r_mode", (float)mode);
                break;
            }
            case 3: { /* Fullscreen */
                float fs = Cvar_VariableValue("vid_fullscreen");
                Cvar_SetValue("vid_fullscreen", fs > 0 ? 0.0f : 1.0f);
                break;
            }
            case 4: { /* Gore */
                float g = Cvar_VariableValue("gore_detail");
                if (dir > 0) { if (g < 2) g += 1; }
                else { if (g > 0) g -= 1; }
                Cvar_SetValue("gore_detail", g);
                break;
            }
            case 5: { /* Difficulty */
                float sk = Cvar_VariableValue("skill");
                if (dir > 0) { if (sk < 3) sk += 1; }
                else { if (sk > 0) sk -= 1; }
                Cvar_SetValue("skill", sk);
                break;
            }
            }
        }
        return;
    }

    if (menu_active == 3) {
        /* Map selection sub-menu */
        if (key == K_ESCAPE) {
            menu_active = 1;
            menu_cursor = 0;
        } else if (key == K_UPARROW || key == 'k') {
            map_cursor--;
            if (map_cursor < 0) map_cursor = MAP_COUNT - 1;
        } else if (key == K_DOWNARROW || key == 'j') {
            map_cursor++;
            if (map_cursor >= MAP_COUNT) map_cursor = 0;
        } else if (key == K_ENTER || key == K_KP_ENTER) {
            char cmd[64];
            Com_sprintf(cmd, sizeof(cmd), "map %s\n", map_names[map_cursor]);
            Cbuf_AddText(cmd);
            menu_active = 0;
        }
        return;
    }

    if (key == K_UPARROW || key == 'k') {
        menu_cursor--;
        if (menu_cursor < 0) menu_cursor = MENU_ITEMS - 1;
    } else if (key == K_DOWNARROW || key == 'j') {
        menu_cursor++;
        if (menu_cursor >= MENU_ITEMS) menu_cursor = 0;
    } else if (key == K_ENTER || key == K_KP_ENTER) {
        switch (menu_cursor) {
        case 0: /* NEW GAME — open map selection */
            menu_active = 3;
            map_cursor = 0;
            break;
        case 1: /* LOAD GAME */
            Cbuf_AddText("loadgame save0\n");
            menu_active = 0;
            break;
        case 2: /* OPTIONS */
            menu_active = 2;
            opt_cursor = 0;
            break;
        case 3: /* CREDITS */
            menu_active = 4;
            break;
        case 4: /* QUIT */
            Cbuf_AddText("quit\n");
            break;
        }
    } else if (key == K_ESCAPE) {
        menu_active = 0;
    }
}

static void SCR_DrawMenu(void)
{
    int w = g_display.width;
    int h = g_display.height;
    int menu_w = 320;
    int menu_h = 280;
    int x = (w - menu_w) / 2;
    int y = (h - menu_h) / 2;
    int i;

    if (!menu_active)
        return;

    /* Semi-transparent dark overlay */
    R_DrawFadeScreenColor(0, 0, 0, 0.7f);

    /* Title */
    R_SetDrawColor(1.0f, 0.8f, 0.0f, 1.0f);
    R_DrawString(x + 40, y + 20, "SOLDIER OF FORTUNE");

    R_SetDrawColor(0.53f, 0.53f, 0.53f, 1.0f);
    R_DrawString(x + 40, y + 40, "Static Recompilation v0.1");

    if (menu_active == 1) {
        /* Main menu items */
        for (i = 0; i < MENU_ITEMS; i++) {
            int item_y = y + 80 + i * 40;

            if (i == menu_cursor) {
                /* Highlight bar */
                R_DrawFill(x + 20, item_y - 2, menu_w - 40, 24, (int)0x40FFFFFF);
                R_SetDrawColor(1.0f, 1.0f, 0.0f, 1.0f);
                R_DrawString(x + 10, item_y, ">");
            } else {
                R_SetDrawColor(0.8f, 0.8f, 0.8f, 1.0f);
            }

            R_DrawString(x + 30, item_y, menu_labels[i]);
        }
    } else if (menu_active == 2) {
        /* Interactive options sub-menu */
        char val[64];
        static const char *opt_labels[OPT_ITEMS] = {
            "Sensitivity", "Volume", "Resolution", "Fullscreen", "Gore", "Difficulty"
        };
        static const char *res_names[] = {
            "320x240", "400x300", "512x384", "640x480", "800x600",
            "960x720", "1024x768", "1152x864", "1280x960", "1280x720",
            "1280x1024", "1600x1200", "1920x1080", "2560x1440", "3840x2160"
        };

        R_SetDrawColor(1.0f, 1.0f, 0.0f, 1.0f);
        R_DrawString(x + 40, y + 60, "OPTIONS");

        for (i = 0; i < OPT_ITEMS; i++) {
            int item_y = y + 90 + i * 28;

            if (i == opt_cursor) {
                R_DrawFill(x + 20, item_y - 2, menu_w - 40, 22, (int)0x40FFFFFF);
                R_SetDrawColor(1.0f, 1.0f, 0.0f, 1.0f);
                R_DrawString(x + 10, item_y, ">");
            } else {
                R_SetDrawColor(0.8f, 0.8f, 0.8f, 1.0f);
            }

            switch (i) {
            case 0:
                Com_sprintf(val, sizeof(val), "%-12s < %.1f >", opt_labels[i],
                            Cvar_VariableValue("sensitivity"));
                break;
            case 1:
                Com_sprintf(val, sizeof(val), "%-12s < %.0f%% >", opt_labels[i],
                            Cvar_VariableValue("s_volume") * 100.0f);
                break;
            case 2: {
                int mode = (int)Cvar_VariableValue("r_mode");
                if (mode < 0 || mode > 14) mode = 6;
                Com_sprintf(val, sizeof(val), "%-12s < %s >", opt_labels[i], res_names[mode]);
                break;
            }
            case 3:
                Com_sprintf(val, sizeof(val), "%-12s < %s >", opt_labels[i],
                            Cvar_VariableValue("vid_fullscreen") > 0 ? "ON" : "OFF");
                break;
            case 4: {
                int gd = (int)Cvar_VariableValue("gore_detail");
                Com_sprintf(val, sizeof(val), "%-12s < %s >", opt_labels[i],
                            gd >= 2 ? "Full" : (gd >= 1 ? "Reduced" : "Off"));
                break;
            }
            case 5: {
                int sk = (int)Cvar_VariableValue("skill");
                static const char *diff_names[] = { "Easy", "Normal", "Hard", "Nightmare" };
                if (sk < 0) sk = 0; if (sk > 3) sk = 3;
                Com_sprintf(val, sizeof(val), "%-12s < %s >", opt_labels[i], diff_names[sk]);
                break;
            }
            }

            R_DrawString(x + 30, item_y, val);
        }

        R_SetDrawColor(0.53f, 0.53f, 0.53f, 1.0f);
        R_DrawString(x + 30, y + 90 + OPT_ITEMS * 28 + 10, "LEFT/RIGHT to change");
    } else if (menu_active == 3) {
        /* Map selection sub-menu */
        R_SetDrawColor(1.0f, 1.0f, 0.0f, 1.0f);
        R_DrawString(x + 40, y + 60, "SELECT MISSION");

        for (i = 0; i < MAP_COUNT; i++) {
            int item_y = y + 90 + i * 22;
            char label[80];

            if (i == map_cursor) {
                R_DrawFill(x + 20, item_y - 2, menu_w - 40, 20, (int)0x40FFFFFF);
                R_SetDrawColor(1.0f, 1.0f, 0.0f, 1.0f);
                R_DrawString(x + 10, item_y, ">");
            } else {
                R_SetDrawColor(0.8f, 0.8f, 0.8f, 1.0f);
            }

            Com_sprintf(label, sizeof(label), "%s - %s", map_names[i], map_titles[i]);
            R_DrawString(x + 30, item_y, label);
        }

        R_SetDrawColor(0.53f, 0.53f, 0.53f, 1.0f);
        R_DrawString(x + 40, y + menu_h - 20, "Press ESC to return");
    } else if (menu_active == 4) {
        /* Credits screen */
        static const char *credits[] = {
            "SOLDIER OF FORTUNE",
            "Static Recompilation",
            "",
            "ORIGINAL GAME",
            "Raven Software (2000)",
            "id Software (Engine)",
            "",
            "RECOMPILATION",
            "Engine & Renderer",
            "Game Logic & AI",
            "Sound & Input",
            "",
            "TECHNOLOGY",
            "id Tech 2 / Quake II Engine",
            "SDL2, OpenGL 1.1",
            "",
            "Press any key to return",
            NULL
        };
        int ci;
        int cy = y + 30;

        for (ci = 0; credits[ci]; ci++) {
            if (credits[ci][0] == '\0') {
                cy += 8;  /* blank line spacing */
                continue;
            }
            /* Section headers in gold, content in white */
            if (ci == 0) {
                R_SetDrawColor(1.0f, 0.8f, 0.0f, 1.0f);
            } else if (credits[ci - 1][0] == '\0' || ci == 1) {
                R_SetDrawColor(1.0f, 0.8f, 0.0f, 0.9f);
            } else {
                R_SetDrawColor(0.8f, 0.8f, 0.8f, 1.0f);
            }
            R_DrawString(x + 40, cy, credits[ci]);
            cy += 16;
        }
    }

    /* Reset draw color */
    R_SetDrawColor(1.0f, 1.0f, 1.0f, 1.0f);
}

/* ==========================================================================
   Scoreboard Display (TAB key)
   ========================================================================== */

typedef struct {
    char    name[32];
    int     kills;
    int     deaths;
    int     score;
    int     ping;
} scoreboard_entry_t;

extern int SV_GetScoreboard(scoreboard_entry_t *entries, int max_entries);
extern qboolean key_down[];  /* from keys.c */
extern qboolean cl_show_scores;  /* from cl_input.c */

static void SCR_DrawScoreboard(void)
{
    scoreboard_entry_t entries[8];
    int count, i;
    int w = g_display.width;
    int h = g_display.height;
    int sb_w = 400;
    int x = (w - sb_w) / 2;
    int y = h / 4;
    char line[128];

    /* Only show when TAB is held or +scores is active */
    if (!key_down[K_TAB] && !cl_show_scores)
        return;

    count = SV_GetScoreboard(entries, 8);
    if (count <= 0)
        return;

    /* Background */
    R_DrawFill(x, y, sb_w, 40 + count * 20, (int)0xC0000000);

    /* Header */
    R_SetDrawColor(1.0f, 0.8f, 0.0f, 1.0f);
    R_DrawString(x + 10, y + 8, "SCOREBOARD");

    R_SetDrawColor(0.67f, 0.67f, 0.67f, 1.0f);
    R_DrawString(x + 10,  y + 28, "Name");
    R_DrawString(x + 180, y + 28, "Kills");
    R_DrawString(x + 240, y + 28, "Deaths");
    R_DrawString(x + 320, y + 28, "Score");

    /* Entries */
    for (i = 0; i < count; i++) {
        int row_y = y + 48 + i * 20;

        R_SetDrawColor(1.0f, 1.0f, 1.0f, 1.0f);
        R_DrawString(x + 10, row_y, entries[i].name);

        Com_sprintf(line, sizeof(line), "%d", entries[i].kills);
        R_DrawString(x + 180, row_y, line);

        Com_sprintf(line, sizeof(line), "%d", entries[i].deaths);
        R_DrawString(x + 240, row_y, line);

        Com_sprintf(line, sizeof(line), "%d", entries[i].score);
        R_DrawString(x + 320, row_y, line);
    }

    R_SetDrawColor(1.0f, 1.0f, 1.0f, 1.0f);
}

/* ==========================================================================
   Chat Message System
   ========================================================================== */

#define MAX_CHAT_LINES  5
#define CHAT_FADE_TIME  5.0f

typedef struct {
    char    text[128];
    float   time;       /* timestamp when message was received */
} chat_line_t;

static chat_line_t chat_lines[MAX_CHAT_LINES];
static int chat_write_idx;

void Chat_AddMessage(const char *text)
{
    chat_line_t *cl = &chat_lines[chat_write_idx % MAX_CHAT_LINES];
    Com_sprintf(cl->text, sizeof(cl->text), "%s", text);
    cl->time = (float)Sys_Milliseconds() / 1000.0f;
    chat_write_idx++;
}

static void SCR_DrawChat(void)
{
    int i;
    int y = g_display.height - 120;  /* above HUD bar */
    float now = (float)Sys_Milliseconds() / 1000.0f;

    for (i = 0; i < MAX_CHAT_LINES; i++) {
        chat_line_t *cl = &chat_lines[i];
        float age;

        if (cl->text[0] == '\0')
            continue;

        age = now - cl->time;
        if (age > CHAT_FADE_TIME)
            continue;

        /* Fade out in last second */
        if (age > CHAT_FADE_TIME - 1.0f) {
            float alpha = CHAT_FADE_TIME - age;
            R_SetDrawColor(1.0f, 1.0f, 1.0f, alpha);
        } else {
            R_SetDrawColor(1.0f, 1.0f, 1.0f, 1.0f);
        }

        R_DrawString(10, y, cl->text);
        y += 12;
    }

    R_SetDrawColor(1.0f, 1.0f, 1.0f, 1.0f);
}

/* ==========================================================================
   Floating Damage Numbers
   ========================================================================== */

#define MAX_DAMAGE_NUMS  16
#define DAMAGE_NUM_LIFETIME  2.0f

typedef struct {
    int     value;
    int     screen_x, screen_y;
    float   birth_time;
    float   vel_y;      /* rise speed in pixels/sec */
    qboolean active;
} damage_num_t;

static damage_num_t dmg_nums[MAX_DAMAGE_NUMS];
static int dmg_num_idx;

void SCR_AddDamageNumber(int damage, int screen_x, int screen_y)
{
    damage_num_t *d = &dmg_nums[dmg_num_idx % MAX_DAMAGE_NUMS];
    d->value = damage;
    /* Default to screen center if 0,0 passed */
    if (screen_x == 0 && screen_y == 0) {
        screen_x = g_display.width / 2;
        screen_y = g_display.height / 2 - 30;
    }
    d->screen_x = screen_x + ((rand() % 40) - 20);
    d->screen_y = screen_y;
    d->birth_time = (float)Sys_Milliseconds() / 1000.0f;
    d->vel_y = -40.0f;  /* rise upward */
    d->active = qtrue;
    dmg_num_idx++;
}

static void SCR_DrawDamageNumbers(void)
{
    int i;
    float now = (float)Sys_Milliseconds() / 1000.0f;

    for (i = 0; i < MAX_DAMAGE_NUMS; i++) {
        damage_num_t *d = &dmg_nums[i];
        float age;
        int y;
        char buf[16];

        if (!d->active) continue;

        age = now - d->birth_time;
        if (age > DAMAGE_NUM_LIFETIME) {
            d->active = qfalse;
            continue;
        }

        y = d->screen_y + (int)(d->vel_y * age);
        {
            float a = 1.0f - age / DAMAGE_NUM_LIFETIME;
            if (a < 0) a = 0;

            /* Color based on damage: high=red, medium=yellow, low=white */
            if (d->value >= 50)
                R_SetDrawColor(1.0f, 0.25f, 0.25f, a);
            else if (d->value >= 20)
                R_SetDrawColor(1.0f, 1.0f, 0.25f, a);
            else
                R_SetDrawColor(1.0f, 1.0f, 1.0f, a);
        }

        Com_sprintf(buf, sizeof(buf), "%d", d->value);
        R_DrawString(d->screen_x, y, buf);
    }

    R_SetDrawColor(1.0f, 1.0f, 1.0f, 1.0f);
}

/* ==========================================================================
   Hit Marker
   ========================================================================== */

#define HITMARKER_DURATION  0.2f

static float hitmarker_time;    /* timestamp when last hit registered */

void SCR_TriggerHitMarker(void)
{
    hitmarker_time = (float)Sys_Milliseconds() / 1000.0f;
}

static void SCR_DrawHitMarker(void)
{
    float now = (float)Sys_Milliseconds() / 1000.0f;
    float age = now - hitmarker_time;
    float alpha;
    int cx, cy;
    int size = 8;
    int gap = 4;

    if (hitmarker_time == 0 || age > HITMARKER_DURATION)
        return;

    alpha = 1.0f - (age / HITMARKER_DURATION);
    if (alpha < 0) alpha = 0;

    cx = g_display.width / 2;
    cy = g_display.height / 2;

    /* Draw X shape — four diagonal lines as small fills */
    R_SetDrawColor(1.0f, 1.0f, 1.0f, alpha);

    /* Top-left to center */
    R_DrawFill(cx - gap - size, cy - gap - size, size, 2, (int)0xFFFFFFFF);
    R_DrawFill(cx - gap - size, cy - gap - size, 2, size, (int)0xFFFFFFFF);

    /* Top-right to center */
    R_DrawFill(cx + gap + 1, cy - gap - size, size, 2, (int)0xFFFFFFFF);
    R_DrawFill(cx + gap + size - 1, cy - gap - size, 2, size, (int)0xFFFFFFFF);

    /* Bottom-left to center */
    R_DrawFill(cx - gap - size, cy + gap + 1, size, 2, (int)0xFFFFFFFF);
    R_DrawFill(cx - gap - size, cy + gap + 1, 2, size, (int)0xFFFFFFFF);

    /* Bottom-right to center */
    R_DrawFill(cx + gap + 1, cy + gap + 1, size, 2, (int)0xFFFFFFFF);
    R_DrawFill(cx + gap + size - 1, cy + gap + 1, 2, size, (int)0xFFFFFFFF);

    R_SetDrawColor(1.0f, 1.0f, 1.0f, 1.0f);
}

/* ==========================================================================
   Damage Direction Indicator
   ========================================================================== */

#define MAX_DMG_DIRS     4
#define DMG_DIR_LIFETIME 1.5f

typedef struct {
    float   angle;      /* direction in degrees (0=front, 90=left, etc.) */
    float   birth_time;
    qboolean active;
} dmg_dir_t;

static dmg_dir_t dmg_dirs[MAX_DMG_DIRS];
static int dmg_dir_idx;

void SCR_AddDamageDirection(float angle)
{
    dmg_dir_t *d = &dmg_dirs[dmg_dir_idx % MAX_DMG_DIRS];
    d->angle = angle;
    d->birth_time = (float)Sys_Milliseconds() / 1000.0f;
    d->active = qtrue;
    dmg_dir_idx++;
}

static void SCR_DrawDamageDirection(void)
{
    int i;
    float now = (float)Sys_Milliseconds() / 1000.0f;
    int cx = g_display.width / 2;
    int cy = g_display.height / 2;

    for (i = 0; i < MAX_DMG_DIRS; i++) {
        dmg_dir_t *d = &dmg_dirs[i];
        float age, alpha;
        float rad;
        int ix, iy;
        int dist = 80;  /* distance from center */

        if (!d->active) continue;

        age = now - d->birth_time;
        if (age > DMG_DIR_LIFETIME) {
            d->active = qfalse;
            continue;
        }

        alpha = 1.0f - (age / DMG_DIR_LIFETIME);
        if (alpha < 0) alpha = 0;
        alpha *= 0.8f;  /* slightly transparent even at start */

        /* Convert angle to screen position around crosshair */
        rad = d->angle * (float)M_PI / 180.0f;
        ix = cx + (int)(sinf(rad) * dist);
        iy = cy - (int)(cosf(rad) * dist);

        /* Draw red chevron/wedge pointing inward */
        R_SetDrawColor(1.0f, 0.0f, 0.0f, alpha);

        /* Arrow body - two thick lines forming a V pointing toward center */
        {
            float perpx = cosf(rad);
            float perpy = sinf(rad);
            int arm = 12;

            /* Left arm */
            R_DrawFill(ix - (int)(perpx * arm) - 1, iy - (int)(perpy * arm) - 1, 3, 3, (int)0xFFFF0000);
            /* Right arm */
            R_DrawFill(ix + (int)(perpx * arm) - 1, iy + (int)(perpy * arm) - 1, 3, 3, (int)0xFFFF0000);
            /* Center tip */
            R_DrawFill(ix - 2, iy - 2, 5, 5, (int)0xFFFF0000);
            /* Connecting bars */
            R_DrawFill(ix - (int)(perpx * arm/2), iy - (int)(perpy * arm/2), 3, 3, (int)0xFFFF0000);
            R_DrawFill(ix + (int)(perpx * arm/2), iy + (int)(perpy * arm/2), 3, 3, (int)0xFFFF0000);
        }
    }

    R_SetDrawColor(1.0f, 1.0f, 1.0f, 1.0f);
}

/* ==========================================================================
   Screen Blood Splatter
   ========================================================================== */

/*
 * When the player takes damage, red splotches appear at random screen
 * positions and fade out over a few seconds. More damage = more splotches.
 * This supplements the existing red damage flash with visceral detail.
 */

#define MAX_BLOOD_SPLATTERS 12
#define SPLATTER_LIFETIME   3.0f

typedef struct {
    int     x, y;           /* screen position */
    int     w, h;           /* splotch size */
    float   birth_time;
    float   alpha;          /* initial alpha */
    qboolean active;
} blood_splatter_t;

static blood_splatter_t blood_splatters[MAX_BLOOD_SPLATTERS];
static int blood_splatter_idx;

void SCR_AddBloodSplatter(int damage)
{
    int count, i;
    int sw = g_display.width;
    int sh = g_display.height;

    /* Scale splotch count by damage: 1 per 10 damage, min 1, max 4 */
    count = damage / 10;
    if (count < 1) count = 1;
    if (count > 4) count = 4;

    for (i = 0; i < count; i++) {
        blood_splatter_t *s = &blood_splatters[blood_splatter_idx % MAX_BLOOD_SPLATTERS];
        s->x = rand() % sw;
        s->y = rand() % sh;
        /* Bias toward edges — more dramatic */
        if (rand() % 3 == 0) {
            /* Place near an edge */
            int edge = rand() % 4;
            if (edge == 0) s->x = rand() % (sw / 4);
            else if (edge == 1) s->x = sw - rand() % (sw / 4);
            else if (edge == 2) s->y = rand() % (sh / 4);
            else s->y = sh - rand() % (sh / 4);
        }
        s->w = 20 + rand() % 40;
        s->h = 15 + rand() % 30;
        s->alpha = 0.3f + (rand() % 20) * 0.01f;
        s->birth_time = (float)Sys_Milliseconds() / 1000.0f;
        s->active = qtrue;
        blood_splatter_idx++;
    }
}

static void SCR_DrawBloodSplatters(void)
{
    int i;
    float now = (float)Sys_Milliseconds() / 1000.0f;

    for (i = 0; i < MAX_BLOOD_SPLATTERS; i++) {
        blood_splatter_t *s = &blood_splatters[i];
        float age, a;
        int color;

        if (!s->active) continue;

        age = now - s->birth_time;
        if (age > SPLATTER_LIFETIME) {
            s->active = qfalse;
            continue;
        }

        /* Fade out over lifetime */
        a = s->alpha * (1.0f - age / SPLATTER_LIFETIME);
        if (a < 0.01f) continue;

        /* Dark red splotch with transparency */
        color = (int)(((int)(a * 255.0f) << 24) | 0x200000);
        R_DrawFill(s->x, s->y, s->w, s->h, color);
        /* Smaller darker center for depth */
        color = (int)(((int)(a * 200.0f) << 24) | 0x100000);
        R_DrawFill(s->x + s->w / 4, s->y + s->h / 4,
                   s->w / 2, s->h / 2, color);
    }
}

/* ==========================================================================
   Pickup Message Queue
   ========================================================================== */

/* ==========================================================================
   Screen Fade System
   ========================================================================== */

/*
 * SCR_StartFade — Begin a screen fade transition
 * target: 0.0 = fully clear, 1.0 = fully black
 * speed: alpha change per second (2.0 = half second fade)
 * hold: seconds to hold at target before auto-releasing (0 = no hold)
 */
void SCR_StartFade(float target, float speed, float hold)
{
    scr_fade_target = target;
    scr_fade_speed = speed;
    scr_fade_hold = hold;
    scr_fade_hold_time = 0;
}

/*
 * SCR_FadeIn — Start fully black and fade to clear
 */
void SCR_FadeIn(float speed)
{
    scr_fade_alpha = 1.0f;
    scr_fade_target = 0.0f;
    scr_fade_speed = speed;
    scr_fade_hold = 0;
    scr_fade_hold_time = 0;
}

static void SCR_UpdateFade(float frametime)
{
    if (scr_fade_alpha < scr_fade_target) {
        scr_fade_alpha += scr_fade_speed * frametime;
        if (scr_fade_alpha >= scr_fade_target) {
            scr_fade_alpha = scr_fade_target;
            if (scr_fade_hold > 0)
                scr_fade_hold_time = (float)Sys_Milliseconds() / 1000.0f;
        }
    } else if (scr_fade_alpha > scr_fade_target) {
        scr_fade_alpha -= scr_fade_speed * frametime;
        if (scr_fade_alpha <= scr_fade_target)
            scr_fade_alpha = scr_fade_target;
    }

    /* Auto-release hold: fade back to clear after hold period */
    if (scr_fade_hold > 0 && scr_fade_hold_time > 0) {
        float now = (float)Sys_Milliseconds() / 1000.0f;
        if (now - scr_fade_hold_time >= scr_fade_hold) {
            scr_fade_target = 0.0f;
            scr_fade_speed = 1.5f;
            scr_fade_hold = 0;
            scr_fade_hold_time = 0;
        }
    }
}

static void SCR_DrawFade(void)
{
    if (scr_fade_alpha < 0.01f)
        return;

    R_DrawFadeScreenColor(0.0f, 0.0f, 0.0f, scr_fade_alpha);
}

/* ==========================================================================
   Pickup Message Queue
   ========================================================================== */

#define MAX_PICKUP_MSGS  4
#define PICKUP_MSG_TIME  2.0f

typedef struct {
    char    text[64];
    float   birth_time;
} pickup_msg_t;

static pickup_msg_t pickup_msgs[MAX_PICKUP_MSGS];
static int pickup_msg_idx;

void SCR_AddPickupMessage(const char *text)
{
    pickup_msg_t *m = &pickup_msgs[pickup_msg_idx % MAX_PICKUP_MSGS];
    Com_sprintf(m->text, sizeof(m->text), "%s", text);
    m->birth_time = (float)Sys_Milliseconds() / 1000.0f;
    pickup_msg_idx++;
}

static void SCR_DrawPickupMessages(void)
{
    int i;
    float now = (float)Sys_Milliseconds() / 1000.0f;
    int cx = g_display.width / 2;
    int y = g_display.height / 2 + 40;  /* below crosshair */

    for (i = 0; i < MAX_PICKUP_MSGS; i++) {
        pickup_msg_t *m = &pickup_msgs[i];
        float age, a;

        if (m->text[0] == '\0') continue;

        age = now - m->birth_time;
        if (age > PICKUP_MSG_TIME) continue;

        a = 1.0f - age / PICKUP_MSG_TIME;
        if (a < 0) a = 0;

        R_SetDrawColor(1.0f, 1.0f, 0.5f, a);
        R_DrawString(cx - (int)(strlen(m->text) * 4), y, m->text);
        y += 14;
    }

    R_SetDrawColor(1.0f, 1.0f, 1.0f, 1.0f);
}

/* ==========================================================================
   Kill Feed — Recent kill notifications in upper-right
   ========================================================================== */

#define MAX_KILLFEED  4
#define KILLFEED_TIME  5.0f

typedef struct {
    char    text[128];
    float   birth_time;
} killfeed_entry_t;

static killfeed_entry_t killfeed[MAX_KILLFEED];
static int killfeed_idx;

void SCR_AddKillFeed(const char *attacker, const char *victim, const char *weapon)
{
    killfeed_entry_t *k = &killfeed[killfeed_idx % MAX_KILLFEED];
    Com_sprintf(k->text, sizeof(k->text), "%s [%s] %s", attacker, weapon, victim);
    k->birth_time = (float)Sys_Milliseconds() / 1000.0f;
    killfeed_idx++;
}

static void SCR_DrawKillFeed(void)
{
    int i;
    float now = (float)Sys_Milliseconds() / 1000.0f;
    int x = g_display.width - 300;
    int y = 8;

    for (i = 0; i < MAX_KILLFEED; i++) {
        killfeed_entry_t *k = &killfeed[i];
        float age;

        if (k->text[0] == '\0') continue;

        age = now - k->birth_time;
        if (age > KILLFEED_TIME) continue;

        {
            float a = (age > KILLFEED_TIME - 1.0f) ?
                      (KILLFEED_TIME - age) : 1.0f;
            if (a < 0) a = 0;
            R_SetDrawColor(1.0f, 0.87f, 0.87f, a);
        }

        R_DrawString(x, y, k->text);
        y += 12;
    }

    R_SetDrawColor(1.0f, 1.0f, 1.0f, 1.0f);
}

/* ==========================================================================
   Loading Screen
   ========================================================================== */

static const char *loading_tips[] = {
    "Aim for the head for maximum damage.",
    "Use cover to avoid enemy fire.",
    "The shotgun is devastating at close range.",
    "Field packs heal you over time.",
    "Night vision goggles drain battery.",
    "Press E to interact with objects.",
    "Different body zones take different damage.",
    "Explore for hidden secrets.",
};

/*
 * SCR_DrawIntermission — Level completion stats screen
 * Shown for 5 seconds or until any key is pressed.
 */
static void SCR_DrawIntermission(void)
{
    int w = g_display.width;
    int h = g_display.height;
    int cx = w / 2;
    int y = h / 4;
    char buf[128];
    int killed_monsters, total_monsters, found_secrets, total_secrets;
    int kills, deaths, score;
    int shots_fired, shots_hit, headshots;
    float elapsed;

    if (!cl_intermission)
        return;

    elapsed = cl_time - cl_intermission_time;

    /* Get stats */
    SV_GetLevelStats(&killed_monsters, &total_monsters,
                     &found_secrets, &total_secrets);
    SV_GetPlayerScore(&kills, &deaths, &score);
    SV_GetPlayerAccuracy(&shots_fired, &shots_hit, &headshots);

    /* Dark overlay */
    R_DrawFill(0, 0, w, h, (int)0xC0000000);

    /* Title */
    R_SetDrawColor(1.0f, 0.85f, 0.0f, 1.0f);
    R_DrawString(cx - 80, y, "MISSION COMPLETE");

    /* Stats box — taller for accuracy info */
    R_DrawFill(cx - 160, y + 30, 320, 220, (int)0x80000000);

    y += 45;
    R_SetDrawColor(0.9f, 0.9f, 0.9f, 1.0f);

    Com_sprintf(buf, sizeof(buf), "Monsters:  %d / %d", killed_monsters, total_monsters);
    R_DrawString(cx - 140, y, buf);
    y += 20;

    Com_sprintf(buf, sizeof(buf), "Secrets:   %d / %d", found_secrets, total_secrets);
    R_DrawString(cx - 140, y, buf);
    y += 20;

    Com_sprintf(buf, sizeof(buf), "Kills:     %d", kills);
    R_DrawString(cx - 140, y, buf);
    y += 20;

    Com_sprintf(buf, sizeof(buf), "Deaths:    %d", deaths);
    R_DrawString(cx - 140, y, buf);
    y += 20;

    Com_sprintf(buf, sizeof(buf), "Score:     %d", score);
    R_DrawString(cx - 140, y, buf);
    y += 25;

    /* Accuracy section */
    R_SetDrawColor(1.0f, 0.85f, 0.0f, 1.0f);
    R_DrawString(cx - 140, y, "--- Accuracy ---");
    y += 18;
    R_SetDrawColor(0.9f, 0.9f, 0.9f, 1.0f);

    Com_sprintf(buf, sizeof(buf), "Shots:     %d / %d", shots_hit, shots_fired);
    R_DrawString(cx - 140, y, buf);
    y += 20;

    {
        int pct = shots_fired > 0 ? (shots_hit * 100) / shots_fired : 0;
        Com_sprintf(buf, sizeof(buf), "Accuracy:  %d%%", pct);
        /* Color-code accuracy: green >50%, yellow 25-50%, red <25% */
        if (pct >= 50)
            R_SetDrawColor(0.2f, 1.0f, 0.2f, 1.0f);
        else if (pct >= 25)
            R_SetDrawColor(1.0f, 1.0f, 0.2f, 1.0f);
        else
            R_SetDrawColor(1.0f, 0.3f, 0.2f, 1.0f);
        R_DrawString(cx - 140, y, buf);
        R_SetDrawColor(0.9f, 0.9f, 0.9f, 1.0f);
    }
    y += 20;

    Com_sprintf(buf, sizeof(buf), "Headshots: %d", headshots);
    R_DrawString(cx - 140, y, buf);
    y += 25;

    /* Time */
    {
        float level_time = cl_time;  /* approximate */
        int minutes = (int)(level_time / 60.0f);
        int seconds = (int)level_time % 60;
        Com_sprintf(buf, sizeof(buf), "Time:      %d:%02d", minutes, seconds);
        R_SetDrawColor(0.7f, 0.7f, 0.7f, 1.0f);
        R_DrawString(cx - 140, y, buf);
    }

    /* Continue prompt */
    y += 40;
    if (((int)(elapsed * 2)) % 2 == 0) {
        R_SetDrawColor(0.6f, 0.6f, 0.6f, 1.0f);
        R_DrawString(cx - 100, y, "Press any key to continue...");
    }

    R_SetDrawColor(1.0f, 1.0f, 1.0f, 1.0f);

    /* Auto-advance after 8 seconds, or on any key/button press */
    if (elapsed > 8.0f || (elapsed > 1.0f && key_down[K_SPACE])) {
        cl_intermission = qfalse;
        if (cl_nextmap[0]) {
            Cbuf_AddText(va("map %s\n", cl_nextmap));
            cl_nextmap[0] = '\0';
        }
    }
}

void SCR_DrawLoadingScreen(const char *mapname)
{
    int screen_w = g_display.width;
    int screen_h = g_display.height;
    int bar_w = screen_w / 2;
    int bar_h = 16;
    int bar_x = (screen_w - bar_w) / 2;
    int bar_y = screen_h / 2 + 40;
    char buf[128];
    int tip_idx;

    R_BeginFrame(0.0f);

    /* Dark background */
    R_DrawFill(0, 0, screen_w, screen_h, 0xFF000000);

    /* Map name */
    Com_sprintf(buf, sizeof(buf), "Loading %s...", mapname ? mapname : "map");
    R_DrawString(screen_w / 2 - (int)strlen(buf) * 4, screen_h / 2 - 20, buf);

    /* Progress bar outline */
    R_DrawFill(bar_x - 1, bar_y - 1, bar_w + 2, bar_h + 2, 0xFF808080);
    R_DrawFill(bar_x, bar_y, bar_w, bar_h, 0xFF202020);

    /* Fill 10% initially — will be updated by loader if possible */
    R_DrawFill(bar_x, bar_y, bar_w / 10, bar_h, 0xFF00AA00);

    /* Random tip */
    tip_idx = (int)(Sys_Milliseconds() % 8);
    Com_sprintf(buf, sizeof(buf), "TIP: %s", loading_tips[tip_idx]);
    R_DrawString(screen_w / 2 - (int)strlen(buf) * 4, bar_y + 30, buf);

    R_EndFrame();
}

static void SCR_DrawScopeOverlay(void)
{
    float zoom_fov;
    int w = g_display.width;
    int h = g_display.height;
    int cx = w / 2;
    int cy = h / 2;
    int radius;
    int bar_color = (int)0xFF000000;

    if (!SV_GetPlayerZoom(&zoom_fov))
        return;

    /* Scope radius — 40% of screen height */
    radius = h * 2 / 5;

    /* Draw dark bars around the scope circle (approximate with rectangles) */
    /* Top and bottom bars */
    R_DrawFill(0, 0, w, cy - radius, bar_color);
    R_DrawFill(0, cy + radius, w, h - (cy + radius), bar_color);
    /* Left and right bars */
    R_DrawFill(0, cy - radius, cx - radius, radius * 2, bar_color);
    R_DrawFill(cx + radius, cy - radius, w - (cx + radius), radius * 2, bar_color);

    /* Fill corners (approximate circle with 8 rectangular strips) */
    {
        int strip;
        for (strip = 0; strip < 16; strip++) {
            float angle = (float)strip / 16.0f * 3.14159265f * 0.5f;
            float ca = (float)cos(angle);
            float sa = (float)sin(angle);
            int sx = (int)(ca * radius);
            int sy = (int)(sa * radius);

            /* Top-left corner fill */
            R_DrawFill(cx - radius, cy - sy - 1, radius - sx, 1, bar_color);
            /* Top-right corner fill */
            R_DrawFill(cx + sx, cy - sy - 1, radius - sx, 1, bar_color);
            /* Bottom-left corner fill */
            R_DrawFill(cx - radius, cy + sy, radius - sx, 1, bar_color);
            /* Bottom-right corner fill */
            R_DrawFill(cx + sx, cy + sy, radius - sx, 1, bar_color);
        }
    }

    /* Scope crosshair — thin cross */
    R_DrawFill(cx - radius, cy, radius * 2, 1, (int)0x80000000);  /* horizontal */
    R_DrawFill(cx, cy - radius, 1, radius * 2, (int)0x80000000);  /* vertical */

    /* Range markers on horizontal line */
    {
        int mark;
        for (mark = 1; mark <= 4; mark++) {
            int off = radius * mark / 5;
            R_DrawFill(cx - off, cy - 3, 1, 7, (int)0x80000000);
            R_DrawFill(cx + off, cy - 3, 1, 7, (int)0x80000000);
        }
    }

    /* Center dot (bright red) */
    R_DrawFill(cx - 1, cy - 1, 3, 3, (int)0xFFFF0000);
}

static void SCR_DrawCrosshair(void)
{
    int cx = g_display.width / 2;
    int cy = g_display.height / 2;
    int size = 2;
    int gap;
    int len = 6;
    int color;
    float move_spread = 0;

    /* Decay spread expansion over time */
    if (crosshair_spread_extra > 0) {
        crosshair_spread_extra -= 0.5f;
        if (crosshair_spread_extra < 0) crosshair_spread_extra = 0;
    }

    /* Dynamic crosshair expansion from player movement */
    {
        vec3_t vel;
        if (SV_GetPlayerVelocity(vel)) {
            float speed = (float)sqrt(vel[0] * vel[0] + vel[1] * vel[1]);
            move_spread = speed * 0.02f;  /* scale velocity to pixel spread */
            if (move_spread > 8.0f) move_spread = 8.0f;
        }
    }

    gap = 3 + (int)(crosshair_spread_extra + move_spread);

    /* Green crosshair normally */
    color = (int)(0xFF00FF00);

    /* Style 1: cross with gap */
    R_DrawFill(cx - gap - len, cy - size/2, len, size, color);  /* left */
    R_DrawFill(cx + gap + 1,  cy - size/2, len, size, color);  /* right */
    R_DrawFill(cx - size/2, cy - gap - len, size, len, color);  /* top */
    R_DrawFill(cx - size/2, cy + gap + 1,  size, len, color);  /* bottom */

    /* Center dot */
    R_DrawFill(cx, cy, 1, 1, color);
}

/*
 * SCR_DrawDeathScreen — "YOU DIED" overlay with red tint and respawn prompt
 */
static float death_fade = 0;   /* fade-in alpha (0..1) */

static void SCR_DrawDeathScreen(void)
{
    int cx = g_display.width / 2;
    int cy = g_display.height / 2;
    float alpha;

    if (!SV_IsPlayerDead()) {
        death_fade = 0;
        return;
    }

    /* Fade in the death overlay */
    if (death_fade < 1.0f) {
        death_fade += 0.02f;
        if (death_fade > 1.0f) death_fade = 1.0f;
    }

    alpha = death_fade;

    /* Red-tinted overlay */
    R_DrawFadeScreenColor(0.3f, 0.0f, 0.0f, alpha * 0.5f);

    /* "YOU DIED" text — large centered */
    R_SetDrawColor(1.0f, 0.15f, 0.1f, alpha);
    R_DrawString(cx - 32, cy - 20, "YOU DIED");

    /* Respawn prompt */
    if (death_fade >= 0.8f) {
        float blink = (float)sin((float)Sys_Milliseconds() * 0.005f);
        float prompt_alpha = (blink > 0) ? alpha : alpha * 0.3f;
        R_SetDrawColor(0.8f, 0.8f, 0.8f, prompt_alpha);
        R_DrawString(cx - 76, cy + 20, "Press FIRE or USE to respawn");
    }

    R_SetDrawColor(1.0f, 1.0f, 1.0f, 1.0f);
}

/*
 * SCR_DrawMinimap — Small radar display showing nearby entities
 * Player at center, rotated to match view direction
 * Red dots = monsters, yellow dots = items
 */

typedef struct {
    vec3_t  origin;
    int     type;       /* 0=generic, 1=monster, 2=other player, 3=item */
    int     health;
} radar_ent_t;

extern int SV_GetRadarEntities(radar_ent_t *out, int max_ents);

static void SCR_DrawMinimap(void)
{
    int map_size = 100;     /* pixel size of minimap */
    int map_x = g_display.width - map_size - 12;
    int map_y = g_display.height - map_size - 60;  /* above HUD bar */
    int map_cx = map_x + map_size / 2;
    int map_cy = map_y + map_size / 2;
    float map_range = 1024.0f;  /* world units visible on radar */
    float scale = (float)map_size / (2.0f * map_range);

    vec3_t player_org, player_ang;
    float vh;
    float yaw_rad;
    float cos_yaw, sin_yaw;
    radar_ent_t ents[64];
    int num_ents, i;

    if (!SV_GetPlayerState(player_org, player_ang, &vh))
        return;

    /* Convert player yaw to radians for rotation */
    yaw_rad = player_ang[1] * (3.14159265f / 180.0f);
    cos_yaw = (float)cos(yaw_rad);
    sin_yaw = (float)sin(yaw_rad);

    /* Background */
    R_DrawFill(map_x, map_y, map_size, map_size, (int)0x80000000);

    /* Border */
    R_DrawFill(map_x, map_y, map_size, 1, (int)0x60FFFFFF);
    R_DrawFill(map_x, map_y + map_size - 1, map_size, 1, (int)0x60FFFFFF);
    R_DrawFill(map_x, map_y, 1, map_size, (int)0x60FFFFFF);
    R_DrawFill(map_x + map_size - 1, map_y, 1, map_size, (int)0x60FFFFFF);

    /* Get entity data through bridge function */
    num_ents = SV_GetRadarEntities(ents, 64);

    for (i = 0; i < num_ents; i++) {
        float dx, dy, rx, ry;
        int px, py;
        int dot_color;

        /* Calculate world offset from player */
        dx = ents[i].origin[0] - player_org[0];
        dy = ents[i].origin[1] - player_org[1];

        /* Rotate to player-relative (forward = up on radar) */
        rx = dx * cos_yaw + dy * sin_yaw;
        ry = -dx * sin_yaw + dy * cos_yaw;

        /* Scale to map pixels */
        px = map_cx + (int)(rx * scale);
        py = map_cy - (int)(ry * scale);

        /* Clip to radar bounds */
        if (px < map_x + 2 || px > map_x + map_size - 3 ||
            py < map_y + 2 || py > map_y + map_size - 3)
            continue;

        /* Color by type */
        if (ents[i].type == 1)
            dot_color = (int)0xFFFF2020;     /* red = monster */
        else if (ents[i].type == 3)
            dot_color = (int)0xFFFFFF40;     /* yellow = item/entity */
        else
            dot_color = (int)0xFF40FF40;     /* green = other */

        /* Draw 3x3 dot */
        R_DrawFill(px - 1, py - 1, 3, 3, dot_color);
    }

    /* Player arrow at center */
    R_DrawFill(map_cx - 1, map_cy - 3, 3, 2, (int)0xFF00FF00);
    R_DrawFill(map_cx, map_cy - 5, 1, 2, (int)0xFF00FF00);
    R_DrawFill(map_cx - 1, map_cy - 1, 3, 3, (int)0xFF008800);

    /* "N" indicator at top of radar (rotated) */
    {
        float north_x = sin_yaw * (map_size / 2 - 8);
        float north_y = cos_yaw * (map_size / 2 - 8);
        int nx = map_cx + (int)north_x;
        int ny = map_cy - (int)north_y;
        if (nx >= map_x + 4 && nx <= map_x + map_size - 12 &&
            ny >= map_y + 2 && ny <= map_y + map_size - 10) {
            R_SetDrawColor(1.0f, 0.8f, 0.0f, 0.8f);
            R_DrawChar(nx, ny, 'N');
        }
    }
}

static void SCR_DrawHUD(float frametime)
{
    int health = 0, max_health = 100;
    char buf[32];

    if (cl_state != CA_ACTIVE)
        return;

    /* Crosshair or scope overlay */
    {
        float zoom_fov;
        if (SV_GetPlayerZoom(&zoom_fov)) {
            SCR_DrawScopeOverlay();
        } else {
            SCR_DrawCrosshair();
        }
    }

    /* Enemy health bar — shown when crosshair is over a monster */
    {
        int ehealth, emax;
        const char *ename;
        if (SV_GetCrosshairTarget(&ehealth, &emax, &ename)) {
            int bar_w = 80;
            int bar_h = 6;
            int bx = g_display.width / 2 - bar_w / 2;
            int by = g_display.height / 2 - 30;
            float pct = emax > 0 ? (float)ehealth / (float)emax : 0;
            int fill_w;

            if (pct > 1.0f) pct = 1.0f;
            if (pct < 0) pct = 0;
            fill_w = (int)(bar_w * pct);

            /* Background */
            R_DrawFill(bx - 1, by - 1, bar_w + 2, bar_h + 2, (int)0x80000000);

            /* Health fill — green > yellow > red */
            if (pct > 0.5f)
                R_DrawFill(bx, by, fill_w, bar_h, (int)0xFF00CC00);
            else if (pct > 0.25f)
                R_DrawFill(bx, by, fill_w, bar_h, (int)0xFFCCCC00);
            else
                R_DrawFill(bx, by, fill_w, bar_h, (int)0xFFCC0000);

            /* Enemy name */
            if (ename) {
                int nlen = (int)strlen(ename);
                R_SetDrawColor(0.9f, 0.9f, 0.9f, 0.8f);
                R_DrawString(g_display.width / 2 - nlen * 4, by - 14, ename);
            }
        }
    }

    /* Use prompt — centered below crosshair */
    {
        extern const char *SV_GetUsePrompt(void);
        const char *prompt = SV_GetUsePrompt();
        if (prompt) {
            int plen = (int)strlen(prompt);
            int px = g_display.width / 2 - plen * 4;
            int py = g_display.height / 2 + 30;
            R_SetDrawColor(1.0f, 1.0f, 1.0f, 0.9f);
            R_DrawString(px, py, prompt);
        }
    }

    /* HUD background bar — bottom of screen (semi-transparent dark) */
    R_DrawFill(0, g_display.height - 48, g_display.width, 48, (int)(0x80000000));

    /* Health display with bar - bottom left */
    if (SV_GetPlayerHealth(&health, &max_health)) {
        int bar_w = 80, bar_h = 6;
        int bx = 16, by = g_display.height - 18;
        float pct = max_health > 0 ? (float)health / (float)max_health : 0;
        int fill_w;

        /* Health label */
        R_SetDrawColor(0.8f, 0.8f, 0.8f, 1.0f);
        R_DrawString(16, g_display.height - 42, "HEALTH");

        /* Health value - color based on amount */
        if (health > 60)
            R_SetDrawColor(1.0f, 1.0f, 1.0f, 1.0f);
        else if (health > 25)
            R_SetDrawColor(1.0f, 1.0f, 0.0f, 1.0f);
        else
            R_SetDrawColor(1.0f, 0.2f, 0.2f, 1.0f);

        snprintf(buf, sizeof(buf), "%d", health);
        R_DrawString(16, g_display.height - 30, buf);

        /* Health bar */
        if (pct > 1.0f) pct = 1.0f;
        if (pct < 0) pct = 0;
        fill_w = (int)(bar_w * pct);
        R_DrawFill(bx, by, bar_w, bar_h, (int)0x40000000);
        if (health > 60)
            R_DrawFill(bx, by, fill_w, bar_h, (int)0xFF00CC00);
        else if (health > 25)
            R_DrawFill(bx, by, fill_w, bar_h, (int)0xFFCCCC00);
        else
            R_DrawFill(bx, by, fill_w, bar_h, (int)0xFFCC2020);
    }

    /* Armor display with bar - bottom left, next to health */
    {
        int armor = 0, armor_max = 0;
        if (SV_GetPlayerArmor(&armor, &armor_max) && armor_max > 0) {
            int bar_w = 60, bar_h = 6;
            int bx = 110, by = g_display.height - 18;
            float pct = armor_max > 0 ? (float)armor / (float)armor_max : 0;
            int fill_w;

            R_SetDrawColor(0.8f, 0.8f, 0.8f, 1.0f);
            R_DrawString(110, g_display.height - 42, "ARMOR");

            if (armor > 100)
                R_SetDrawColor(0.3f, 0.5f, 1.0f, 1.0f);
            else if (armor > 0)
                R_SetDrawColor(0.5f, 0.7f, 1.0f, 1.0f);
            else
                R_SetDrawColor(0.4f, 0.4f, 0.4f, 1.0f);

            snprintf(buf, sizeof(buf), "%d", armor);
            R_DrawString(110, g_display.height - 30, buf);

            /* Armor bar */
            if (pct > 1.0f) pct = 1.0f;
            if (pct < 0) pct = 0;
            fill_w = (int)(bar_w * pct);
            R_DrawFill(bx, by, bar_w, bar_h, (int)0x40000000);
            R_DrawFill(bx, by, fill_w, bar_h, (int)0xFF3070FF);
        }
    }

    /* Key display - bottom left, next to armor */
    {
        int keys = SV_GetPlayerKeys();
        if (keys) {
            int kx = 184;
            int ky = g_display.height - 36;

            R_SetDrawColor(0.8f, 0.8f, 0.8f, 1.0f);
            R_DrawString(kx, ky - 4, "KEYS");

            if (keys & 1) { R_DrawFill(kx, ky + 8, 10, 10, (int)0xFFFF0000); kx += 14; }
            if (keys & 2) { R_DrawFill(kx, ky + 8, 10, 10, (int)0xFF0040FF); kx += 14; }
            if (keys & 4) { R_DrawFill(kx, ky + 8, 10, 10, (int)0xFFC0C0C0); kx += 14; }
            if (keys & 8) { R_DrawFill(kx, ky + 8, 10, 10, (int)0xFFFFD700); }
        }
    }

    /* Weapon display - bottom right */
    {
        const char *wname = SV_GetPlayerWeapon();
        if (wname && wname[0]) {
            int len = (int)strlen(wname);
            int x = g_display.width - 16 - len * 8;

            R_SetDrawColor(0.8f, 0.8f, 0.8f, 1.0f);
            R_DrawString(x, g_display.height - 40, wname);
        }

        /* Ammo/magazine display - below weapon name */
        {
            int mag = 0, mag_max = 0, reserve = 0;
            int ammo = 0, ammo_max = 0;
            char abuf[48];
            int alen, ax;

            if (SV_GetPlayerMagazine(&mag, &mag_max, &reserve) && mag_max > 0) {
                /* Magazine weapon: show mag / mag_max + reserve */
                snprintf(abuf, sizeof(abuf), "%d/%d  +%d", mag, mag_max, reserve);

                /* Color based on magazine fullness */
                if (mag > mag_max / 4)
                    R_SetDrawColor(1.0f, 1.0f, 1.0f, 1.0f);
                else if (mag > 0)
                    R_SetDrawColor(1.0f, 1.0f, 0.0f, 1.0f);  /* yellow = low */
                else
                    R_SetDrawColor(1.0f, 0.2f, 0.2f, 1.0f);  /* red = empty */
            } else if (SV_GetPlayerAmmo(&ammo, &ammo_max)) {
                /* Non-magazine weapon */
                if (ammo_max > 0)
                    snprintf(abuf, sizeof(abuf), "%d / %d", ammo, ammo_max);
                else
                    snprintf(abuf, sizeof(abuf), "%d", ammo);

                if (ammo > 10)
                    R_SetDrawColor(1.0f, 1.0f, 1.0f, 1.0f);
                else if (ammo > 0)
                    R_SetDrawColor(1.0f, 1.0f, 0.0f, 1.0f);
                else
                    R_SetDrawColor(1.0f, 0.2f, 0.2f, 1.0f);
            } else {
                abuf[0] = '\0';
            }

            if (abuf[0]) {
                alen = (int)strlen(abuf);
                ax = g_display.width - 16 - alen * 8;
                R_DrawString(ax, g_display.height - 28, abuf);
            }
        }

        /* Reload progress bar */
        if (SV_IsPlayerReloading()) {
            extern float SV_GetReloadProgress(void);
            float prog = SV_GetReloadProgress();
            int bar_w = 60;
            int bar_h = 4;
            int bx = g_display.width - 16 - bar_w;
            int by = g_display.height - 16;
            int filled = (int)(bar_w * prog);

            /* Background */
            R_DrawFill(bx, by, bar_w, bar_h, (int)0x99333333);
            /* Progress */
            R_DrawFill(bx, by, filled, bar_h, (int)0xE6FFCC33);
            /* Label */
            R_SetDrawColor(1.0f, 0.8f, 0.2f, 0.9f);
            R_DrawString(bx, by - 12, "RELOADING");
        }

        /* Reset to default green for console */
        R_SetDrawColor(0.0f, 1.0f, 0.0f, 1.0f);
    }

    /* Compass - top center */
    {
        vec3_t cpos, cang;
        float cvh = 0;
        if (SV_GetPlayerState(cpos, cang, &cvh)) {
            float yaw = cang[1];
            const char *dir;

            /* Normalize yaw to 0-360 */
            while (yaw < 0) yaw += 360;
            while (yaw >= 360) yaw -= 360;

            if (yaw >= 337.5f || yaw < 22.5f)      dir = "E";
            else if (yaw < 67.5f)                    dir = "NE";
            else if (yaw < 112.5f)                   dir = "N";
            else if (yaw < 157.5f)                   dir = "NW";
            else if (yaw < 202.5f)                   dir = "W";
            else if (yaw < 247.5f)                   dir = "SW";
            else if (yaw < 292.5f)                   dir = "S";
            else                                     dir = "SE";

            {
                int clen = (int)strlen(dir);
                int cx = (g_display.width - clen * 8) / 2;
                R_SetDrawColor(0.9f, 0.9f, 0.9f, 0.7f);
                R_DrawString(cx, 8, dir);
                R_SetDrawColor(0.0f, 1.0f, 0.0f, 1.0f);
            }
        }
    }

    /* Pickup message - center screen, fades out */
    if (hud_pickup_time > 0) {
        float alpha = hud_pickup_time > 1.0f ? 1.0f : hud_pickup_time;
        int len = (int)strlen(hud_pickup_msg);
        int x = (g_display.width - len * 8) / 2;
        int y = g_display.height / 2 + 40;

        R_SetDrawColor(1.0f, 1.0f, 1.0f, alpha);
        R_DrawString(x, y, hud_pickup_msg);
        R_SetDrawColor(0.0f, 1.0f, 0.0f, 1.0f);

        hud_pickup_time -= frametime;
    }

    /* Damage flash — full-screen red overlay */
    {
        float blend[4];
        SV_GetPlayerBlend(blend);
        if (blend[3] > 0.01f) {
            R_DrawFadeScreenColor(blend[0], blend[1], blend[2], blend[3]);
        }
    }

    /* Low health blood vignette — red borders when hurt */
    if (health > 0 && health < 30) {
        float intensity = 1.0f - (float)health / 30.0f;  /* 0 at 30hp, 1 at 0hp */
        float alpha = intensity * 0.5f;
        int border = (int)(40.0f * intensity) + 10;
        int w = g_display.width;
        int h = g_display.height;

        /* Red borders on all four edges */
        R_DrawFadeScreenColor(0.5f, 0.0f, 0.0f, alpha * 0.3f);
        R_DrawFill(0, 0, w, border, (int)(((int)(alpha * 180.0f) << 24) | 0x400000));
        R_DrawFill(0, h - border, w, border, (int)(((int)(alpha * 180.0f) << 24) | 0x400000));
        R_DrawFill(0, 0, border, h, (int)(((int)(alpha * 180.0f) << 24) | 0x400000));
        R_DrawFill(w - border, 0, border, h, (int)(((int)(alpha * 180.0f) << 24) | 0x400000));
    }

    /* Death message */
    if (health <= 0) {
        R_SetDrawColor(1.0f, 0.2f, 0.2f, 1.0f);
        R_DrawString((g_display.width - 14 * 8) / 2, g_display.height / 2 - 16, "YOU ARE DEAD");
        R_SetDrawColor(0.8f, 0.8f, 0.8f, 1.0f);
        R_DrawString((g_display.width - 23 * 8) / 2, g_display.height / 2, "Press FIRE to respawn");
        R_SetDrawColor(0.0f, 1.0f, 0.0f, 1.0f);
    }

    /* Nearby item name display */
    {
        const char *item_name = SV_GetNearbyItemName();
        if (item_name) {
            /* Format: strip prefix (weapon_, item_, ammo_) and capitalize */
            const char *display = item_name;
            if (strncmp(display, "weapon_", 7) == 0) display += 7;
            else if (strncmp(display, "item_", 5) == 0) display += 5;
            else if (strncmp(display, "ammo_", 5) == 0) display += 5;

            {
                int len = (int)strlen(display);
                int px = (g_display.width - len * 8) / 2;
                int py = g_display.height / 2 + 30;

                R_SetDrawColor(1.0f, 1.0f, 0.6f, 0.9f);
                R_DrawString(px, py, display);
                R_SetDrawColor(1.0f, 1.0f, 1.0f, 1.0f);
            }
        }
    }

    /* Stamina bar — above HUD bar, center-left */
    {
        extern float SV_GetPlayerStamina(void);
        extern qboolean SV_IsPlayerSprinting(void);
        float stam = SV_GetPlayerStamina();
        int bar_w = 60, bar_h = 4;
        int bx = g_display.width / 2 - bar_w / 2;
        int by = g_display.height - 56;
        int fill_w = (int)(bar_w * stam / 100.0f);

        if (stam < 100.0f || SV_IsPlayerSprinting()) {
            /* Only show when not full or sprinting */
            R_DrawFill(bx, by, bar_w, bar_h, (int)0x60000000);
            if (stam > 50.0f)
                R_DrawFill(bx, by, fill_w, bar_h, (int)0xCC00CC00);
            else if (stam > 20.0f)
                R_DrawFill(bx, by, fill_w, bar_h, (int)0xCCCCCC00);
            else
                R_DrawFill(bx, by, fill_w, bar_h, (int)0xCCCC3300);

            R_SetDrawColor(0.7f, 0.7f, 0.7f, 0.6f);
            R_DrawString(bx - 56, by - 2, "SPRINT");
            R_SetDrawColor(1.0f, 1.0f, 1.0f, 1.0f);
        }
    }

    /* Bullet time charge — small bar below stamina */
    {
        extern float SV_GetPlayerBulletTimeCharge(void);
        extern qboolean SV_IsBulletTimeActive(void);
        float charge = SV_GetPlayerBulletTimeCharge();
        int bar_w = 60, bar_h = 4;
        int bx = g_display.width / 2 - bar_w / 2;
        int by = g_display.height - 64;
        int fill_w = (int)(bar_w * charge / 100.0f);

        if (charge > 0 || SV_IsBulletTimeActive()) {
            R_DrawFill(bx, by, bar_w, bar_h, (int)0x60000000);

            if (SV_IsBulletTimeActive()) {
                /* Pulsing gold when active */
                R_DrawFill(bx, by, fill_w, bar_h, (int)0xFFFFD700);
            } else if (charge >= 50.0f) {
                /* Ready to activate — bright gold */
                R_DrawFill(bx, by, fill_w, bar_h, (int)0xCCFFD700);
            } else {
                /* Charging — dim gold */
                R_DrawFill(bx, by, fill_w, bar_h, (int)0x80997700);
            }

            R_SetDrawColor(0.8f, 0.7f, 0.3f, 0.6f);
            R_DrawString(bx - 80, by - 2, "BULLET TIME");
            R_SetDrawColor(1.0f, 1.0f, 1.0f, 1.0f);
        }
    }

    /* Minimap radar */
    SCR_DrawMinimap();

    /* Compass heading — shows cardinal direction above minimap */
    {
        vec3_t view_pos, view_ang;
        float vh_unused;
        if (SV_GetPlayerState(view_pos, view_ang, &vh_unused)) {
            float yaw = view_ang[1];
            int heading;
            const char *dir_label;
            char compass_str[16];
            int cx;

            while (yaw < 0) yaw += 360.0f;
            while (yaw >= 360.0f) yaw -= 360.0f;
            heading = (int)yaw;

            if (yaw >= 337.5f || yaw < 22.5f) dir_label = "E";
            else if (yaw < 67.5f)  dir_label = "NE";
            else if (yaw < 112.5f) dir_label = "N";
            else if (yaw < 157.5f) dir_label = "NW";
            else if (yaw < 202.5f) dir_label = "W";
            else if (yaw < 247.5f) dir_label = "SW";
            else if (yaw < 292.5f) dir_label = "S";
            else                   dir_label = "SE";

            Com_sprintf(compass_str, sizeof(compass_str), "%s %d", dir_label, heading);
            cx = g_display.width - 112 + 50 - (int)(strlen(compass_str) * 4);
            R_SetDrawColor(0.8f, 0.9f, 1.0f, 0.8f);
            R_DrawString(cx, g_display.height - 170, compass_str);
            R_SetDrawColor(1.0f, 1.0f, 1.0f, 1.0f);
        }
    }

    /* Developer HUD — FPS, position, entity count */
    if (developer && developer->value) {
        static int  fps_frame_count;
        static float fps_next_update;
        static int  fps_display;
        vec3_t pos, ang;
        float vh = 0;

        /* FPS counter — update once per second */
        fps_frame_count++;
        if (cl_time >= fps_next_update) {
            fps_display = fps_frame_count;
            fps_frame_count = 0;
            fps_next_update = cl_time + 1.0f;
        }

        R_SetDrawColor(1.0f, 1.0f, 0.0f, 1.0f);

        /* FPS — top right */
        {
            char fpsbuf[16];
            int flen, fx;
            snprintf(fpsbuf, sizeof(fpsbuf), "FPS: %d", fps_display);
            flen = (int)strlen(fpsbuf);
            fx = g_display.width - 8 - flen * 8;
            R_DrawString(fx, 8, fpsbuf);
        }

        /* Position — top left */
        if (SV_GetPlayerState(pos, ang, &vh)) {
            char posbuf[64];
            snprintf(posbuf, sizeof(posbuf), "%.0f %.0f %.0f", pos[0], pos[1], pos[2]);
            R_DrawString(8, 8, posbuf);
        }

        /* Entity count — below FPS */
        {
            char entbuf[32];
            int elen, ex;
            snprintf(entbuf, sizeof(entbuf), "Ents: %d", SV_GetEntityCount());
            elen = (int)strlen(entbuf);
            ex = g_display.width - 8 - elen * 8;
            R_DrawString(ex, 20, entbuf);
        }

        /* Score + rank — below entity count */
        {
            int kills, deaths, score;
            char scrbuf[64];
            int slen, sx;
            const char *rank;

            SV_GetPlayerScore(&kills, &deaths, &score);

            /* Rank based on cumulative score */
            if (score >= 500)      rank = "Colonel";
            else if (score >= 300) rank = "Major";
            else if (score >= 200) rank = "Captain";
            else if (score >= 100) rank = "Lieutenant";
            else if (score >= 50)  rank = "Sergeant";
            else if (score >= 20)  rank = "Corporal";
            else                   rank = "Private";

            snprintf(scrbuf, sizeof(scrbuf), "%s  K:%d D:%d S:%d", rank, kills, deaths, score);
            slen = (int)strlen(scrbuf);
            sx = g_display.width - 8 - slen * 8;
            R_SetDrawColor(0.9f, 0.85f, 0.6f, 1.0f);
            R_DrawString(sx, 32, scrbuf);
            R_SetDrawColor(1.0f, 1.0f, 1.0f, 1.0f);
        }

        /* Level stats — monsters and secrets */
        {
            int km, tm, fs, ts;
            char statbuf[48];
            int statlen, statx;
            SV_GetLevelStats(&km, &tm, &fs, &ts);
            snprintf(statbuf, sizeof(statbuf), "M:%d/%d S:%d/%d", km, tm, fs, ts);
            statlen = (int)strlen(statbuf);
            statx = g_display.width - 8 - statlen * 8;
            R_DrawString(statx, 44, statbuf);
        }

        R_SetDrawColor(0.0f, 1.0f, 0.0f, 1.0f);
    }
}

void SV_Init(void) {}
void SV_Shutdown(const char *finalmsg, qboolean reconnect)
{
    (void)finalmsg;
    (void)reconnect;
    SV_ShutdownGameProgs();
}
/* Server frame — runs game at 10Hz tick rate */
static int sv_frame_residual = 0;

/* Forward declarations — entity interpolation (renderer/r_main.c) */
extern void R_SetInterpFraction(float frac);
extern void R_UpdateEntityInterp(void);

void SV_Frame(int msec)
{
    sv_frame_residual += msec;

    /* Run game frames at 100ms intervals (10 Hz) */
    while (sv_frame_residual >= 100) {
        /* Snapshot entity positions before tick for interpolation */
        R_UpdateEntityInterp();

        sv_frame_residual -= 100;
        SV_RunGameFrame();
    }

    /* Calculate interpolation fraction for rendering (0..1 between ticks) */
    R_SetInterpFraction(sv_frame_residual / 100.0f);
}
