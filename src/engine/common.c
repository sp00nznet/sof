/*
 * common.c - Engine common functions
 *
 * Based on Quake II common.c (id Software GPL).
 * Provides console output, error handling, and the main engine loop.
 *
 * SoF exports: Com_Printf, Com_DPrintf, Com_Error
 * Original addresses: Com_Printf=0x1DE70, Com_DPrintf=0x1E070, Com_Error=0x1E130
 *
 * Qcommon_Init (0x20BB0): Refs z_stats, error, disconnect, subliminal
 * Com_Init (0x23760): Refs cpu_mmx, cpu_amd3d, timescale, game
 */

#include "../common/qcommon.h"
#include "win32_compat.h"
#include "../renderer/r_local.h"
#include "../ghoul/ghoul.h"
#include "../sound/snd_local.h"
#include "../client/keys.h"
#include "../client/console.h"

#include <time.h>

/* Forward declarations — input system (client/in_sdl.c) */
extern void IN_Init(void);
extern void IN_Shutdown(void);
extern void IN_GetMouseDelta(int *dx, int *dy);

/* Forward declarations — client input (client/cl_input.c) */
extern void CL_InitInput(void);
extern void CL_CreateCmd(usercmd_t *cmd, int msec);

/* Forward declarations — server frame (server/sv_game.c) */
extern void SV_RunGameFrame(void);
extern void SV_ClientThink(usercmd_t *cmd);
extern qboolean SV_GetPlayerState(vec3_t origin, vec3_t angles, float *viewheight);
extern qboolean SV_GetPlayerHealth(int *health, int *max_health);
extern const char *SV_GetPlayerWeapon(void);
extern qboolean SV_GetPlayerAmmo(int *ammo, int *ammo_max);
extern qboolean SV_GetPlayerMagazine(int *magazine, int *mag_max, int *reserve);
extern void SV_GetPlayerBlend(float *blend);
extern qboolean SV_GetPlayerArmor(int *armor, int *armor_max);
extern void SV_GetPlayerScore(int *kills, int *deaths, int *score);
extern void SV_GetLevelStats(int *killed_monsters, int *total_monsters,
                             int *found_secrets, int *total_secrets);
extern int  SV_GetEntityCount(void);

/* Forward declaration — freecam toggle (defined below in client section) */
static void Cmd_Freecam_f(void);

/* Forward declaration — client command forwarding */
extern void SV_ExecuteClientCommand(void);

static void Cmd_SaveGame_f(void)
{
    const char *name = Cmd_Argc() > 1 ? Cmd_Argv(1) : "quick";
    char buf[256];
    snprintf(buf, sizeof(buf), "save %s", name);
    Cmd_TokenizeString(buf, qfalse);
    SV_ExecuteClientCommand();
}

static void Cmd_LoadGame_f(void)
{
    const char *name = Cmd_Argc() > 1 ? Cmd_Argv(1) : "quick";
    char buf[256];
    snprintf(buf, sizeof(buf), "load %s", name);
    Cmd_TokenizeString(buf, qfalse);
    SV_ExecuteClientCommand();
}

static void Cmd_ForwardToServer(void)
{
    /* Re-tokenize with "cmd" stripped so gi.argv(0) returns the actual command */
    const char *args = Cmd_Args();
    if (args && args[0]) {
        Cmd_TokenizeString((char *)args, qfalse);
        SV_ExecuteClientCommand();
    }
}

extern void Key_WriteBindings(FILE *f);

static void Cmd_WriteConfig_f(void)
{
    const char *filename = Cmd_Argc() > 1 ? Cmd_Argv(1) : "config.cfg";
    FILE *f;

    f = fopen(filename, "w");
    if (!f) {
        Com_Printf("Couldn't write %s\n", filename);
        return;
    }

    fprintf(f, "// Generated by SoF Recomp\n\n");
    fprintf(f, "// Key bindings\n");
    Key_WriteBindings(f);
    fprintf(f, "\n// Cvars\n");
    fclose(f);

    /* Cvar_WriteVariables appends to file */
    Cvar_WriteVariables(filename);

    Com_Printf("Wrote %s\n", filename);
}

/* Forward declarations — HUD, menu, scoreboard, chat, damage, pickup, killfeed */
static void SCR_DrawHUD(float frametime);
static void SCR_DrawMenu(void);
static void SCR_DrawScoreboard(void);
static void SCR_DrawChat(void);
static void SCR_DrawDamageNumbers(void);
static void SCR_DrawPickupMessages(void);
static void SCR_DrawKillFeed(void);

/* ANGLE2SHORT / SHORT2ANGLE for usercmd angle encoding */
#define ANGLE2SHORT(x)  ((int)((x)*65536.0f/360.0f) & 65535)
#define SHORT2ANGLE(x)  ((x)*(360.0f/65536.0f))

/* ==========================================================================
   Global Cvars
   ========================================================================== */

cvar_t  *developer;
cvar_t  *timescale;
cvar_t  *fixedtime;
cvar_t  *dedicated;
cvar_t  *com_speeds;
cvar_t  *logfile_cvar;
cvar_t  *showtrace;

/* SoF-specific cvars discovered through binary analysis */
cvar_t  *sof_version;
cvar_t  *gore_detail;

static FILE *logfile;
static int  server_state;

/* ==========================================================================
   Console Output
   ========================================================================== */

static char     com_printbuf[8192];

void Com_Printf(const char *fmt, ...)
{
    va_list argptr;
    char    msg[4096];

    va_start(argptr, fmt);
    vsnprintf(msg, sizeof(msg), fmt, argptr);
    va_end(argptr);

    /* Print to stdout */
    fputs(msg, stdout);
    fflush(stdout);

    /* Log to file if enabled */
    if (logfile) {
        fputs(msg, logfile);
        fflush(logfile);
    }

    /* Route to in-game console */
    Con_Print(msg);
}

void Com_DPrintf(const char *fmt, ...)
{
    va_list argptr;
    char    msg[4096];

    if (!developer || !developer->value)
        return;

    va_start(argptr, fmt);
    vsnprintf(msg, sizeof(msg), fmt, argptr);
    va_end(argptr);

    Com_Printf("%s", msg);
}

/* ==========================================================================
   Error Handling
   ========================================================================== */

void Com_Error(int code, const char *fmt, ...)
{
    va_list     argptr;
    static char msg[4096];
    static int  recursive = 0;

    if (recursive)
        Sys_Error("recursive error after: %s", msg);

    recursive = 1;

    va_start(argptr, fmt);
    vsnprintf(msg, sizeof(msg), fmt, argptr);
    va_end(argptr);

    switch (code) {
    case ERR_DISCONNECT:
        CL_Drop();
        recursive = 0;
        return;

    case ERR_DROP:
        Com_Printf("********************\nERROR: %s\n********************\n", msg);
        SV_Shutdown(va("server crashed: %s\n", msg), qfalse);
        CL_Drop();
        recursive = 0;
        return;

    case ERR_FATAL:
    default:
        SV_Shutdown(va("server fatal crashed: %s\n", msg), qfalse);
        CL_Shutdown();
        break;
    }

    Sys_Error("%s", msg);
}

/* ==========================================================================
   Engine Initialization
   ========================================================================== */

void Qcommon_Init(int argc, char **argv)
{
    Com_Printf("\n");
    Com_Printf("=== Soldier of Fortune ===\n");
    Com_Printf("Static Recompilation v%s\n", "0.1.0");
    Com_Printf("Based on id Tech 2 (Quake II Engine)\n");
    Com_Printf("Original by Raven Software, 2000\n");
    Com_Printf("\n");

    /* Initialize subsystems in dependency order */
    Z_Init();
    Cbuf_Init();
    Cmd_Init();
    Cvar_Init();

    /* Register core commands */
    Cmd_AddCommand("quit", Sys_Quit);
    Cmd_AddCommand("error", NULL);  /* placeholder */
    Cmd_AddCommand("freecam", Cmd_Freecam_f);
    Cmd_AddCommand("cmd", Cmd_ForwardToServer);
    Cmd_AddCommand("savegame", Cmd_SaveGame_f);
    Cmd_AddCommand("loadgame", Cmd_LoadGame_f);
    Cmd_AddCommand("writeconfig", Cmd_WriteConfig_f);

    /* Register core cvars */
    developer = Cvar_Get("developer", "0", 0);
    timescale = Cvar_Get("timescale", "1", 0);
    fixedtime = Cvar_Get("fixedtime", "0", 0);
    dedicated = Cvar_Get("dedicated", "0", CVAR_NOSET);
    com_speeds = Cvar_Get("com_speeds", "0", 0);
    logfile_cvar = Cvar_Get("logfile", "0", 0);
    showtrace = Cvar_Get("showtrace", "0", 0);

    /* SoF-specific cvars */
    sof_version = Cvar_Get("version", "SoF Recomp v0.1.0", CVAR_SERVERINFO | CVAR_NOSET);
    gore_detail = Cvar_Get("gore_detail", "2", CVAR_ARCHIVE);  /* 0=off, 1=low, 2=full */

    /* SoF gore zone cvars (from binary analysis: 85 cvars registered) */
    Cvar_Get("ghl_specular", "1", CVAR_ARCHIVE);
    Cvar_Get("ghl_mip", "1", CVAR_ARCHIVE);

    /* Initialize filesystem */
    FS_InitFilesystem();

    /* Execute default config */
    Cbuf_AddText("exec default.cfg\n");
    Cbuf_AddText("exec config.cfg\n");
    Cbuf_Execute();

    /* Parse command line arguments */
    {
        int i;
        for (i = 1; i < argc; i++) {
            if (argv[i][0] == '+') {
                Cbuf_AddText(va("%s ", argv[i] + 1));
                /* Add remaining args until next + command */
                while (i + 1 < argc && argv[i + 1][0] != '+') {
                    i++;
                    Cbuf_AddText(va("%s ", argv[i]));
                }
                Cbuf_AddText("\n");
            }
        }
        Cbuf_Execute();
    }

    /* Initialize subsystems that depend on filesystem */
    /* TODO: NET_Init(), Netchan_Init() */

    Com_Printf("====== Soldier of Fortune Initialized ======\n\n");

    /* Initialize GHOUL model system */
    GHOUL_Init();

    /* Initialize game module (was gamex86.dll in original) */
    SV_InitGameProgs();

    /* Initialize console */
    Con_Init();

    /* Initialize input */
    IN_Init();
    CL_InitInput();

    /* Initialize renderer */
    if (!dedicated->value) {
        R_Init(NULL, NULL);
    }

    /* Initialize sound (replaces Defsnd.dll/EAXSnd.dll/A3Dsnd.dll) */
    S_Init();
}

/* ==========================================================================
   Main Frame
   ========================================================================== */

void Qcommon_Frame(int msec)
{
    int     time_before, time_between, time_after;

    if (fixedtime && fixedtime->value)
        msec = (int)fixedtime->value;
    else if (timescale && timescale->value)
        msec = (int)(msec * timescale->value);

    if (msec < 1)
        msec = 1;

    if (com_speeds && com_speeds->value)
        time_before = Sys_Milliseconds();

    /* Execute any pending console commands */
    Cbuf_Execute();

    if (com_speeds && com_speeds->value)
        time_between = Sys_Milliseconds();

    /* Run server frame */
    SV_Frame(msec);

    /* Run client frame (input, view setup) */
    if (!dedicated || !dedicated->value) {
        CL_Frame(msec);

        /* Animate console slide */
        {
            float speed = msec * 0.004f;  /* ~4 units per ms */
            if (con.current_frac < con.dest_frac) {
                con.current_frac += speed;
                if (con.current_frac > con.dest_frac)
                    con.current_frac = con.dest_frac;
            } else if (con.current_frac > con.dest_frac) {
                con.current_frac -= speed;
                if (con.current_frac < con.dest_frac)
                    con.current_frac = con.dest_frac;
            }
        }

        /* Render frame */
        R_BeginFrame(0.0f);
        SCR_DrawHUD(msec / 1000.0f);
        SCR_DrawDamageNumbers();
        SCR_DrawPickupMessages();
        SCR_DrawKillFeed();
        SCR_DrawChat();
        SCR_DrawScoreboard();
        SCR_DrawMenu();
        Con_DrawNotify();
        Con_DrawConsole(con.current_frac);
        R_EndFrame();
    }

    if (com_speeds && com_speeds->value) {
        time_after = Sys_Milliseconds();
        Com_Printf("all:%3d sv:%3d cl:%3d\n",
            time_after - time_before,
            time_between - time_before,
            time_after - time_between);
    }
}

/* ==========================================================================
   Shutdown
   ========================================================================== */

void Qcommon_Shutdown(void)
{
    /* Auto-save config on clean shutdown */
    Cmd_WriteConfig_f();

    if (logfile) {
        fclose(logfile);
        logfile = NULL;
    }
}

/* ==========================================================================
   Client State
   ========================================================================== */

typedef enum {
    CA_DISCONNECTED,    /* not connected to a server */
    CA_CONNECTING,      /* awaiting connection response */
    CA_CONNECTED,       /* connection established, loading map */
    CA_ACTIVE           /* fully in-game, rendering world */
} connstate_t;

static connstate_t  cl_state = CA_DISCONNECTED;
static refdef_t     cl_refdef;          /* current frame's render view */
static float        cl_time;            /* accumulated time */
static vec3_t       cl_viewangles;      /* accumulated mouse look angles */
static qboolean     cl_use_freecam;     /* toggle: freecam vs player movement */

void CL_Init(void)
{
    memset(&cl_refdef, 0, sizeof(cl_refdef));
    cl_state = CA_DISCONNECTED;
    cl_time = 0;
    VectorClear(cl_viewangles);
    cl_use_freecam = qfalse;
}

void CL_Drop(void)
{
    cl_state = CA_DISCONNECTED;
}

void CL_Shutdown(void)
{
    S_Shutdown();
    IN_Shutdown();
    R_Shutdown();
}

/* Toggle freecam console command */
static void Cmd_Freecam_f(void)
{
    cl_use_freecam = !cl_use_freecam;
    Com_Printf("Freecam: %s\n", cl_use_freecam ? "ON" : "OFF");
}

/*
 * CL_Frame — Client frame processing
 *
 * Runs every frame. Handles input, updates the view, builds refdef_t.
 * In the original Q2, this also handled network parsing and prediction.
 * For our unified binary, the server runs in-process.
 */
void CL_Frame(int msec)
{
    float frametime = msec / 1000.0f;
    cl_time += frametime;

    /* If world is loaded and we're disconnected, go active */
    if (R_WorldLoaded() && cl_state < CA_ACTIVE)
        cl_state = CA_ACTIVE;

    if (cl_state != CA_ACTIVE)
        return;

    /* Gather mouse input (always, for both modes) */
    if (!Con_IsVisible()) {
        int mx, my;
        IN_GetMouseDelta(&mx, &my);
        cl_viewangles[1] -= mx * 0.15f;    /* yaw */
        cl_viewangles[0] += my * 0.15f;    /* pitch */
        if (cl_viewangles[0] > 89) cl_viewangles[0] = 89;
        if (cl_viewangles[0] < -89) cl_viewangles[0] = -89;
    }

    if (cl_use_freecam) {
        /* Freecam mode — direct camera control */
        if (!Con_IsVisible()) {
            extern qboolean key_down[];
            float fwd = 0, side = 0, up = 0;
            if (key_down['w']) fwd += 1;
            if (key_down['s']) fwd -= 1;
            if (key_down['d']) side += 1;
            if (key_down['a']) side -= 1;
            if (key_down[' ']) up += 200.0f * frametime;
            if (key_down[133]) up -= 200.0f * frametime;

            R_SetCameraAngles(cl_viewangles);
            R_UpdateCamera(fwd, side, up, 0, 0, frametime);
        }

        /* Build refdef from freecam */
        {
            vec3_t org, ang;
            R_GetCameraOrigin(org);
            R_GetCameraAngles(ang);

            memset(&cl_refdef, 0, sizeof(cl_refdef));
            cl_refdef.x = 0;
            cl_refdef.y = 0;
            cl_refdef.width = g_display.width;
            cl_refdef.height = g_display.height;
            cl_refdef.fov_x = 90.0f;
            cl_refdef.fov_y = 73.74f;
            cl_refdef.time = cl_time;
            VectorCopy(org, cl_refdef.vieworg);
            VectorCopy(ang, cl_refdef.viewangles);
        }
    } else {
        /* Player movement mode — build usercmd, send to game */
        usercmd_t cmd;
        CL_CreateCmd(&cmd, msec);

        /* Pack view angles into usercmd */
        cmd.angles[0] = (short)ANGLE2SHORT(cl_viewangles[0]);
        cmd.angles[1] = (short)ANGLE2SHORT(cl_viewangles[1]);
        cmd.angles[2] = 0;

        /* Send to game module */
        if (!Con_IsVisible())
            SV_ClientThink(&cmd);

        /* Build refdef from player entity state */
        {
            vec3_t org, ang;
            float vh = 0;

            if (SV_GetPlayerState(org, ang, &vh)) {
                org[2] += vh;  /* add viewheight for eye position */

                memset(&cl_refdef, 0, sizeof(cl_refdef));
                cl_refdef.x = 0;
                cl_refdef.y = 0;
                cl_refdef.width = g_display.width;
                cl_refdef.height = g_display.height;
                cl_refdef.fov_x = 90.0f;
                cl_refdef.fov_y = 73.74f;
                cl_refdef.time = cl_time;
                VectorCopy(org, cl_refdef.vieworg);
                VectorCopy(ang, cl_refdef.viewangles);

                /* Sync camera for PVS culling */
                R_SetCameraOrigin(org);
                R_SetCameraAngles(ang);
            }
        }
    }
}

/* ==========================================================================
   HUD Drawing
   ========================================================================== */

/* Pickup message display */
static char     hud_pickup_msg[64];
static float    hud_pickup_time;

void HUD_SetPickupMessage(const char *msg)
{
    Q_strncpyz(hud_pickup_msg, msg, sizeof(hud_pickup_msg));
    hud_pickup_time = 3.0f;  /* display for 3 seconds */
}

/* Crosshair spread expansion — set by game when firing */
static float crosshair_spread_extra;  /* extra gap from weapon spread */
static float crosshair_spread_decay;  /* decay timer */

void SCR_SetCrosshairSpread(float spread)
{
    crosshair_spread_extra = spread * 200.0f;  /* scale to pixels */
    if (crosshair_spread_extra > 20) crosshair_spread_extra = 20;
}

/* ==========================================================================
   Main Menu System
   ========================================================================== */

#define MENU_ITEMS  4
static const char *menu_labels[MENU_ITEMS] = {
    "NEW GAME", "LOAD GAME", "OPTIONS", "QUIT"
};

static int  menu_active = 0;    /* 0=hidden, 1=main, 2=options */
static int  menu_cursor = 0;

/* Exposed to key handler */
int  M_IsActive(void) { return menu_active; }

void M_Open(void)
{
    menu_active = 1;
    menu_cursor = 0;
}

void M_Close(void)
{
    menu_active = 0;
}

void M_Keydown(int key)
{
    if (menu_active == 2) {
        /* Options sub-menu — ESC returns to main */
        if (key == K_ESCAPE) {
            menu_active = 1;
            menu_cursor = 2;
        }
        return;
    }

    if (key == K_UPARROW || key == 'k') {
        menu_cursor--;
        if (menu_cursor < 0) menu_cursor = MENU_ITEMS - 1;
    } else if (key == K_DOWNARROW || key == 'j') {
        menu_cursor++;
        if (menu_cursor >= MENU_ITEMS) menu_cursor = 0;
    } else if (key == K_ENTER || key == K_KP_ENTER) {
        switch (menu_cursor) {
        case 0: /* NEW GAME */
            Cbuf_AddText("map sof1\n");
            menu_active = 0;
            break;
        case 1: /* LOAD GAME */
            Cbuf_AddText("loadgame save0\n");
            menu_active = 0;
            break;
        case 2: /* OPTIONS */
            menu_active = 2;
            break;
        case 3: /* QUIT */
            Cbuf_AddText("quit\n");
            break;
        }
    } else if (key == K_ESCAPE) {
        menu_active = 0;
    }
}

static void SCR_DrawMenu(void)
{
    int w = g_display.width;
    int h = g_display.height;
    int menu_w = 320;
    int menu_h = 280;
    int x = (w - menu_w) / 2;
    int y = (h - menu_h) / 2;
    int i;

    if (!menu_active)
        return;

    /* Semi-transparent dark overlay */
    R_DrawFadeScreenColor(0, 0, 0, 0.7f);

    /* Title */
    R_SetDrawColor(0xFF, 0xCC, 0x00, 0xFF);
    R_DrawString(x + 40, y + 20, "SOLDIER OF FORTUNE");

    R_SetDrawColor(0x88, 0x88, 0x88, 0xFF);
    R_DrawString(x + 40, y + 40, "Static Recompilation v0.1");

    if (menu_active == 1) {
        /* Main menu items */
        for (i = 0; i < MENU_ITEMS; i++) {
            int item_y = y + 80 + i * 40;

            if (i == menu_cursor) {
                /* Highlight bar */
                R_DrawFill(x + 20, item_y - 2, menu_w - 40, 24, (int)0x40FFFFFF);
                R_SetDrawColor(0xFF, 0xFF, 0x00, 0xFF);
                R_DrawString(x + 10, item_y, ">");
            } else {
                R_SetDrawColor(0xCC, 0xCC, 0xCC, 0xFF);
            }

            R_DrawString(x + 30, item_y, menu_labels[i]);
        }
    } else if (menu_active == 2) {
        /* Options sub-menu */
        char val[64];

        R_SetDrawColor(0xFF, 0xFF, 0x00, 0xFF);
        R_DrawString(x + 40, y + 80, "OPTIONS");

        R_SetDrawColor(0xCC, 0xCC, 0xCC, 0xFF);
        Com_sprintf(val, sizeof(val), "Sensitivity: %.1f", Cvar_VariableValue("sensitivity"));
        R_DrawString(x + 40, y + 120, val);

        Com_sprintf(val, sizeof(val), "Volume: %.1f", Cvar_VariableValue("s_volume"));
        R_DrawString(x + 40, y + 140, val);

        Com_sprintf(val, sizeof(val), "Gore: %s",
                    Cvar_VariableValue("gore_detail") >= 2 ? "Full" : "Reduced");
        R_DrawString(x + 40, y + 160, val);

        R_SetDrawColor(0x88, 0x88, 0x88, 0xFF);
        R_DrawString(x + 40, y + 200, "Press ESC to return");
    }

    /* Reset draw color */
    R_SetDrawColor(0xFF, 0xFF, 0xFF, 0xFF);
}

/* ==========================================================================
   Scoreboard Display (TAB key)
   ========================================================================== */

typedef struct {
    char    name[32];
    int     kills;
    int     deaths;
    int     score;
    int     ping;
} scoreboard_entry_t;

extern int SV_GetScoreboard(scoreboard_entry_t *entries, int max_entries);
extern qboolean key_down[];  /* from keys.c */

static void SCR_DrawScoreboard(void)
{
    scoreboard_entry_t entries[8];
    int count, i;
    int w = g_display.width;
    int h = g_display.height;
    int sb_w = 400;
    int x = (w - sb_w) / 2;
    int y = h / 4;
    char line[128];

    /* Only show when TAB is held */
    if (!key_down[K_TAB])
        return;

    count = SV_GetScoreboard(entries, 8);
    if (count <= 0)
        return;

    /* Background */
    R_DrawFill(x, y, sb_w, 40 + count * 20, (int)0xC0000000);

    /* Header */
    R_SetDrawColor(0xFF, 0xCC, 0x00, 0xFF);
    R_DrawString(x + 10, y + 8, "SCOREBOARD");

    R_SetDrawColor(0xAA, 0xAA, 0xAA, 0xFF);
    R_DrawString(x + 10,  y + 28, "Name");
    R_DrawString(x + 180, y + 28, "Kills");
    R_DrawString(x + 240, y + 28, "Deaths");
    R_DrawString(x + 320, y + 28, "Score");

    /* Entries */
    for (i = 0; i < count; i++) {
        int row_y = y + 48 + i * 20;

        R_SetDrawColor(0xFF, 0xFF, 0xFF, 0xFF);
        R_DrawString(x + 10, row_y, entries[i].name);

        Com_sprintf(line, sizeof(line), "%d", entries[i].kills);
        R_DrawString(x + 180, row_y, line);

        Com_sprintf(line, sizeof(line), "%d", entries[i].deaths);
        R_DrawString(x + 240, row_y, line);

        Com_sprintf(line, sizeof(line), "%d", entries[i].score);
        R_DrawString(x + 320, row_y, line);
    }

    R_SetDrawColor(0xFF, 0xFF, 0xFF, 0xFF);
}

/* ==========================================================================
   Chat Message System
   ========================================================================== */

#define MAX_CHAT_LINES  5
#define CHAT_FADE_TIME  5.0f

typedef struct {
    char    text[128];
    float   time;       /* timestamp when message was received */
} chat_line_t;

static chat_line_t chat_lines[MAX_CHAT_LINES];
static int chat_write_idx;

void Chat_AddMessage(const char *text)
{
    chat_line_t *cl = &chat_lines[chat_write_idx % MAX_CHAT_LINES];
    Com_sprintf(cl->text, sizeof(cl->text), "%s", text);
    cl->time = (float)Sys_Milliseconds() / 1000.0f;
    chat_write_idx++;
}

static void SCR_DrawChat(void)
{
    int i;
    int y = g_display.height - 120;  /* above HUD bar */
    float now = (float)Sys_Milliseconds() / 1000.0f;

    for (i = 0; i < MAX_CHAT_LINES; i++) {
        chat_line_t *cl = &chat_lines[i];
        float age;

        if (cl->text[0] == '\0')
            continue;

        age = now - cl->time;
        if (age > CHAT_FADE_TIME)
            continue;

        /* Fade out in last second */
        if (age > CHAT_FADE_TIME - 1.0f) {
            int alpha = (int)(255.0f * (CHAT_FADE_TIME - age));
            R_SetDrawColor(0xFF, 0xFF, 0xFF, alpha);
        } else {
            R_SetDrawColor(0xFF, 0xFF, 0xFF, 0xFF);
        }

        R_DrawString(10, y, cl->text);
        y += 12;
    }

    R_SetDrawColor(0xFF, 0xFF, 0xFF, 0xFF);
}

/* ==========================================================================
   Floating Damage Numbers
   ========================================================================== */

#define MAX_DAMAGE_NUMS  16
#define DAMAGE_NUM_LIFETIME  2.0f

typedef struct {
    int     value;
    int     screen_x, screen_y;
    float   birth_time;
    float   vel_y;      /* rise speed in pixels/sec */
    qboolean active;
} damage_num_t;

static damage_num_t dmg_nums[MAX_DAMAGE_NUMS];
static int dmg_num_idx;

void SCR_AddDamageNumber(int damage, int screen_x, int screen_y)
{
    damage_num_t *d = &dmg_nums[dmg_num_idx % MAX_DAMAGE_NUMS];
    d->value = damage;
    /* Default to screen center if 0,0 passed */
    if (screen_x == 0 && screen_y == 0) {
        screen_x = g_display.width / 2;
        screen_y = g_display.height / 2 - 30;
    }
    d->screen_x = screen_x + ((rand() % 40) - 20);
    d->screen_y = screen_y;
    d->birth_time = (float)Sys_Milliseconds() / 1000.0f;
    d->vel_y = -40.0f;  /* rise upward */
    d->active = qtrue;
    dmg_num_idx++;
}

static void SCR_DrawDamageNumbers(void)
{
    int i;
    float now = (float)Sys_Milliseconds() / 1000.0f;

    for (i = 0; i < MAX_DAMAGE_NUMS; i++) {
        damage_num_t *d = &dmg_nums[i];
        float age;
        int y;
        int alpha;
        char buf[16];

        if (!d->active) continue;

        age = now - d->birth_time;
        if (age > DAMAGE_NUM_LIFETIME) {
            d->active = qfalse;
            continue;
        }

        y = d->screen_y + (int)(d->vel_y * age);
        alpha = (int)(255.0f * (1.0f - age / DAMAGE_NUM_LIFETIME));
        if (alpha < 0) alpha = 0;

        /* Color based on damage: high=red, medium=yellow, low=white */
        if (d->value >= 50)
            R_SetDrawColor(0xFF, 0x40, 0x40, alpha);
        else if (d->value >= 20)
            R_SetDrawColor(0xFF, 0xFF, 0x40, alpha);
        else
            R_SetDrawColor(0xFF, 0xFF, 0xFF, alpha);

        Com_sprintf(buf, sizeof(buf), "%d", d->value);
        R_DrawString(d->screen_x, y, buf);
    }

    R_SetDrawColor(0xFF, 0xFF, 0xFF, 0xFF);
}

/* ==========================================================================
   Pickup Message Queue
   ========================================================================== */

#define MAX_PICKUP_MSGS  4
#define PICKUP_MSG_TIME  2.0f

typedef struct {
    char    text[64];
    float   birth_time;
} pickup_msg_t;

static pickup_msg_t pickup_msgs[MAX_PICKUP_MSGS];
static int pickup_msg_idx;

void SCR_AddPickupMessage(const char *text)
{
    pickup_msg_t *m = &pickup_msgs[pickup_msg_idx % MAX_PICKUP_MSGS];
    Com_sprintf(m->text, sizeof(m->text), "%s", text);
    m->birth_time = (float)Sys_Milliseconds() / 1000.0f;
    pickup_msg_idx++;
}

static void SCR_DrawPickupMessages(void)
{
    int i;
    float now = (float)Sys_Milliseconds() / 1000.0f;
    int cx = g_display.width / 2;
    int y = g_display.height / 2 + 40;  /* below crosshair */

    for (i = 0; i < MAX_PICKUP_MSGS; i++) {
        pickup_msg_t *m = &pickup_msgs[i];
        float age;
        int alpha;

        if (m->text[0] == '\0') continue;

        age = now - m->birth_time;
        if (age > PICKUP_MSG_TIME) continue;

        alpha = (int)(255.0f * (1.0f - age / PICKUP_MSG_TIME));
        if (alpha < 0) alpha = 0;

        R_SetDrawColor(0xFF, 0xFF, 0x80, alpha);
        R_DrawString(cx - (int)(strlen(m->text) * 4), y, m->text);
        y += 14;
    }

    R_SetDrawColor(0xFF, 0xFF, 0xFF, 0xFF);
}

/* ==========================================================================
   Kill Feed — Recent kill notifications in upper-right
   ========================================================================== */

#define MAX_KILLFEED  4
#define KILLFEED_TIME  5.0f

typedef struct {
    char    text[128];
    float   birth_time;
} killfeed_entry_t;

static killfeed_entry_t killfeed[MAX_KILLFEED];
static int killfeed_idx;

void SCR_AddKillFeed(const char *attacker, const char *victim, const char *weapon)
{
    killfeed_entry_t *k = &killfeed[killfeed_idx % MAX_KILLFEED];
    Com_sprintf(k->text, sizeof(k->text), "%s [%s] %s", attacker, weapon, victim);
    k->birth_time = (float)Sys_Milliseconds() / 1000.0f;
    killfeed_idx++;
}

static void SCR_DrawKillFeed(void)
{
    int i;
    float now = (float)Sys_Milliseconds() / 1000.0f;
    int x = g_display.width - 300;
    int y = 8;

    for (i = 0; i < MAX_KILLFEED; i++) {
        killfeed_entry_t *k = &killfeed[i];
        float age;

        if (k->text[0] == '\0') continue;

        age = now - k->birth_time;
        if (age > KILLFEED_TIME) continue;

        {
            int alpha = (age > KILLFEED_TIME - 1.0f) ?
                        (int)(255.0f * (KILLFEED_TIME - age)) : 255;
            if (alpha < 0) alpha = 0;
            R_SetDrawColor(0xFF, 0xDD, 0xDD, alpha);
        }

        R_DrawString(x, y, k->text);
        y += 12;
    }

    R_SetDrawColor(0xFF, 0xFF, 0xFF, 0xFF);
}

/* ==========================================================================
   Loading Screen
   ========================================================================== */

static const char *loading_tips[] = {
    "Aim for the head for maximum damage.",
    "Use cover to avoid enemy fire.",
    "The shotgun is devastating at close range.",
    "Field packs heal you over time.",
    "Night vision goggles drain battery.",
    "Press E to interact with objects.",
    "Different body zones take different damage.",
    "Explore for hidden secrets.",
};

void SCR_DrawLoadingScreen(const char *mapname)
{
    int screen_w = g_display.width;
    int screen_h = g_display.height;
    int bar_w = screen_w / 2;
    int bar_h = 16;
    int bar_x = (screen_w - bar_w) / 2;
    int bar_y = screen_h / 2 + 40;
    char buf[128];
    int tip_idx;

    R_BeginFrame(0.0f);

    /* Dark background */
    R_DrawFill(0, 0, screen_w, screen_h, 0xFF000000);

    /* Map name */
    Com_sprintf(buf, sizeof(buf), "Loading %s...", mapname ? mapname : "map");
    R_DrawString(screen_w / 2 - (int)strlen(buf) * 4, screen_h / 2 - 20, buf);

    /* Progress bar outline */
    R_DrawFill(bar_x - 1, bar_y - 1, bar_w + 2, bar_h + 2, 0xFF808080);
    R_DrawFill(bar_x, bar_y, bar_w, bar_h, 0xFF202020);

    /* Fill 10% initially — will be updated by loader if possible */
    R_DrawFill(bar_x, bar_y, bar_w / 10, bar_h, 0xFF00AA00);

    /* Random tip */
    tip_idx = (int)(Sys_Milliseconds() % 8);
    Com_sprintf(buf, sizeof(buf), "TIP: %s", loading_tips[tip_idx]);
    R_DrawString(screen_w / 2 - (int)strlen(buf) * 4, bar_y + 30, buf);

    R_EndFrame();
}

static void SCR_DrawCrosshair(void)
{
    int cx = g_display.width / 2;
    int cy = g_display.height / 2;
    int size = 2;
    int gap = 3 + (int)crosshair_spread_extra;
    int len = 6;
    int color;

    /* Decay spread expansion over time */
    if (crosshair_spread_extra > 0) {
        crosshair_spread_extra -= 0.5f;
        if (crosshair_spread_extra < 0) crosshair_spread_extra = 0;
    }

    /* Green crosshair normally */
    color = (int)(0xFF00FF00);

    /* Style 1: cross with gap */
    R_DrawFill(cx - gap - len, cy - size/2, len, size, color);  /* left */
    R_DrawFill(cx + gap + 1,  cy - size/2, len, size, color);  /* right */
    R_DrawFill(cx - size/2, cy - gap - len, size, len, color);  /* top */
    R_DrawFill(cx - size/2, cy + gap + 1,  size, len, color);  /* bottom */

    /* Center dot */
    R_DrawFill(cx, cy, 1, 1, color);
}

static void SCR_DrawHUD(float frametime)
{
    int health = 0, max_health = 100;
    char buf[32];

    if (cl_state != CA_ACTIVE)
        return;

    /* Crosshair */
    SCR_DrawCrosshair();

    /* HUD background bar — bottom of screen (semi-transparent dark) */
    R_DrawFill(0, g_display.height - 48, g_display.width, 48, (int)(0x80000000));

    /* Health display - bottom left */
    if (SV_GetPlayerHealth(&health, &max_health)) {
        /* Health label */
        R_SetDrawColor(0.8f, 0.8f, 0.8f, 1.0f);
        R_DrawString(16, g_display.height - 40, "HEALTH");

        /* Health value - color based on amount */
        if (health > 60)
            R_SetDrawColor(1.0f, 1.0f, 1.0f, 1.0f);
        else if (health > 25)
            R_SetDrawColor(1.0f, 1.0f, 0.0f, 1.0f);
        else
            R_SetDrawColor(1.0f, 0.2f, 0.2f, 1.0f);

        snprintf(buf, sizeof(buf), "%d", health);
        R_DrawString(16, g_display.height - 28, buf);
    }

    /* Armor display - bottom left, next to health */
    {
        int armor = 0, armor_max = 0;
        if (SV_GetPlayerArmor(&armor, &armor_max) && armor_max > 0) {
            R_SetDrawColor(0.8f, 0.8f, 0.8f, 1.0f);
            R_DrawString(100, g_display.height - 40, "ARMOR");

            if (armor > 100)
                R_SetDrawColor(0.3f, 0.5f, 1.0f, 1.0f);
            else if (armor > 0)
                R_SetDrawColor(0.5f, 0.7f, 1.0f, 1.0f);
            else
                R_SetDrawColor(0.4f, 0.4f, 0.4f, 1.0f);

            snprintf(buf, sizeof(buf), "%d", armor);
            R_DrawString(100, g_display.height - 28, buf);
        }
    }

    /* Weapon display - bottom right */
    {
        const char *wname = SV_GetPlayerWeapon();
        if (wname && wname[0]) {
            int len = (int)strlen(wname);
            int x = g_display.width - 16 - len * 8;

            R_SetDrawColor(0.8f, 0.8f, 0.8f, 1.0f);
            R_DrawString(x, g_display.height - 40, wname);
        }

        /* Ammo/magazine display - below weapon name */
        {
            int mag = 0, mag_max = 0, reserve = 0;
            int ammo = 0, ammo_max = 0;
            char abuf[48];
            int alen, ax;

            if (SV_GetPlayerMagazine(&mag, &mag_max, &reserve) && mag_max > 0) {
                /* Magazine weapon: show mag / mag_max + reserve */
                snprintf(abuf, sizeof(abuf), "%d/%d  +%d", mag, mag_max, reserve);

                /* Color based on magazine fullness */
                if (mag > mag_max / 4)
                    R_SetDrawColor(1.0f, 1.0f, 1.0f, 1.0f);
                else if (mag > 0)
                    R_SetDrawColor(1.0f, 1.0f, 0.0f, 1.0f);  /* yellow = low */
                else
                    R_SetDrawColor(1.0f, 0.2f, 0.2f, 1.0f);  /* red = empty */
            } else if (SV_GetPlayerAmmo(&ammo, &ammo_max)) {
                /* Non-magazine weapon */
                if (ammo_max > 0)
                    snprintf(abuf, sizeof(abuf), "%d / %d", ammo, ammo_max);
                else
                    snprintf(abuf, sizeof(abuf), "%d", ammo);

                if (ammo > 10)
                    R_SetDrawColor(1.0f, 1.0f, 1.0f, 1.0f);
                else if (ammo > 0)
                    R_SetDrawColor(1.0f, 1.0f, 0.0f, 1.0f);
                else
                    R_SetDrawColor(1.0f, 0.2f, 0.2f, 1.0f);
            } else {
                abuf[0] = '\0';
            }

            if (abuf[0]) {
                alen = (int)strlen(abuf);
                ax = g_display.width - 16 - alen * 8;
                R_DrawString(ax, g_display.height - 28, abuf);
            }
        }

        /* Reset to default green for console */
        R_SetDrawColor(0.0f, 1.0f, 0.0f, 1.0f);
    }

    /* Compass - top center */
    {
        vec3_t cpos, cang;
        float cvh = 0;
        if (SV_GetPlayerState(cpos, cang, &cvh)) {
            float yaw = cang[1];
            const char *dir;

            /* Normalize yaw to 0-360 */
            while (yaw < 0) yaw += 360;
            while (yaw >= 360) yaw -= 360;

            if (yaw >= 337.5f || yaw < 22.5f)      dir = "E";
            else if (yaw < 67.5f)                    dir = "NE";
            else if (yaw < 112.5f)                   dir = "N";
            else if (yaw < 157.5f)                   dir = "NW";
            else if (yaw < 202.5f)                   dir = "W";
            else if (yaw < 247.5f)                   dir = "SW";
            else if (yaw < 292.5f)                   dir = "S";
            else                                     dir = "SE";

            {
                int clen = (int)strlen(dir);
                int cx = (g_display.width - clen * 8) / 2;
                R_SetDrawColor(0.9f, 0.9f, 0.9f, 0.7f);
                R_DrawString(cx, 8, dir);
                R_SetDrawColor(0.0f, 1.0f, 0.0f, 1.0f);
            }
        }
    }

    /* Pickup message - center screen, fades out */
    if (hud_pickup_time > 0) {
        float alpha = hud_pickup_time > 1.0f ? 1.0f : hud_pickup_time;
        int len = (int)strlen(hud_pickup_msg);
        int x = (g_display.width - len * 8) / 2;
        int y = g_display.height / 2 + 40;

        R_SetDrawColor(1.0f, 1.0f, 1.0f, alpha);
        R_DrawString(x, y, hud_pickup_msg);
        R_SetDrawColor(0.0f, 1.0f, 0.0f, 1.0f);

        hud_pickup_time -= frametime;
    }

    /* Damage flash — full-screen red overlay */
    {
        float blend[4];
        SV_GetPlayerBlend(blend);
        if (blend[3] > 0.01f) {
            R_DrawFadeScreenColor(blend[0], blend[1], blend[2], blend[3]);
        }
    }

    /* Death message */
    if (health <= 0) {
        R_SetDrawColor(1.0f, 0.2f, 0.2f, 1.0f);
        R_DrawString((g_display.width - 14 * 8) / 2, g_display.height / 2 - 16, "YOU ARE DEAD");
        R_SetDrawColor(0.8f, 0.8f, 0.8f, 1.0f);
        R_DrawString((g_display.width - 23 * 8) / 2, g_display.height / 2, "Press FIRE to respawn");
        R_SetDrawColor(0.0f, 1.0f, 0.0f, 1.0f);
    }

    /* Developer HUD — FPS, position, entity count */
    if (developer && developer->value) {
        static int  fps_frame_count;
        static float fps_next_update;
        static int  fps_display;
        vec3_t pos, ang;
        float vh = 0;

        /* FPS counter — update once per second */
        fps_frame_count++;
        if (cl_time >= fps_next_update) {
            fps_display = fps_frame_count;
            fps_frame_count = 0;
            fps_next_update = cl_time + 1.0f;
        }

        R_SetDrawColor(1.0f, 1.0f, 0.0f, 1.0f);

        /* FPS — top right */
        {
            char fpsbuf[16];
            int flen, fx;
            snprintf(fpsbuf, sizeof(fpsbuf), "FPS: %d", fps_display);
            flen = (int)strlen(fpsbuf);
            fx = g_display.width - 8 - flen * 8;
            R_DrawString(fx, 8, fpsbuf);
        }

        /* Position — top left */
        if (SV_GetPlayerState(pos, ang, &vh)) {
            char posbuf[64];
            snprintf(posbuf, sizeof(posbuf), "%.0f %.0f %.0f", pos[0], pos[1], pos[2]);
            R_DrawString(8, 8, posbuf);
        }

        /* Entity count — below FPS */
        {
            char entbuf[32];
            int elen, ex;
            snprintf(entbuf, sizeof(entbuf), "Ents: %d", SV_GetEntityCount());
            elen = (int)strlen(entbuf);
            ex = g_display.width - 8 - elen * 8;
            R_DrawString(ex, 20, entbuf);
        }

        /* Score — below entity count */
        {
            int kills, deaths, score;
            char scrbuf[48];
            int slen, sx;
            SV_GetPlayerScore(&kills, &deaths, &score);
            snprintf(scrbuf, sizeof(scrbuf), "K:%d D:%d S:%d", kills, deaths, score);
            slen = (int)strlen(scrbuf);
            sx = g_display.width - 8 - slen * 8;
            R_DrawString(sx, 32, scrbuf);
        }

        /* Level stats — monsters and secrets */
        {
            int km, tm, fs, ts;
            char statbuf[48];
            int statlen, statx;
            SV_GetLevelStats(&km, &tm, &fs, &ts);
            snprintf(statbuf, sizeof(statbuf), "M:%d/%d S:%d/%d", km, tm, fs, ts);
            statlen = (int)strlen(statbuf);
            statx = g_display.width - 8 - statlen * 8;
            R_DrawString(statx, 44, statbuf);
        }

        R_SetDrawColor(0.0f, 1.0f, 0.0f, 1.0f);
    }
}

void SV_Init(void) {}
void SV_Shutdown(const char *finalmsg, qboolean reconnect)
{
    (void)finalmsg;
    (void)reconnect;
    SV_ShutdownGameProgs();
}
/* Server frame — runs game at 10Hz tick rate */
static int sv_frame_residual = 0;

void SV_Frame(int msec)
{
    sv_frame_residual += msec;

    /* Run game frames at 100ms intervals (10 Hz) */
    while (sv_frame_residual >= 100) {
        sv_frame_residual -= 100;
        SV_RunGameFrame();
    }
}
